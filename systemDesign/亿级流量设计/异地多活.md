# 异地多活

> 如自己接触到到的 GSLB 就是 DNS 的负载均衡

## 需求（Why）

极端情况（机房断电、火灾、地震等）下，需要保证在 **异地** 中有多个 **活跃** 的系统，当某地失败后，请求转发到异地活跃的系统。


## 设计标准

- 无论用户请求哪一个节点，都能正常相响应（正常时访问异地可以）
- 某些系统故障，用户访问其他系统也能正常响应（异常时访问异地也可以）

## 分类

- 同城异区
- 跨城异地
- 跨国异地

距离越近，访问速度越快；不同距离，应对的灾害等级不同。

## 难点：数据一致性

> 插一句，负载均衡问题的解决：
> 通过 DNS 的负载均衡或 nginx 的负载均衡

> 一般情况下，数据只留在本地，尤其是跨国应用数据。

难点：异地多活**数据不一致的问题**。

原因：距离远，访问慢，一致性差。

影响：如果数据存在不一致，那么异地容灾就是空谈。（灾后异地无法走正常业务）

解决：
- 只保证核心数据的一致性（如已存在用户的登录）。
- 只保证最终一致性，不考虑实时一致性。
- 自建网络，专线，加快请求。

同步手段：
- 中间件主从复制。redis、mysql
- 消息队列的订阅发布。
- 二次读取。从北京查不到，再去广州查一次。
- 回源读取。用户在 A 生成的 session，让用户访问回到 A 中心。
- 重新生成数据。

优先保证核心业务：登录（因为是已存用户，调用量大）。

## 设计步骤

- 对业务分级：从对公司的影响和对用户的影响两方面看
- 对数据分类：识别出核心业务数据的特征
    - 唯一性。如手机号必须同步，不允许在异地用同一个手机号注册
    - 实时性。如银行账户余额。
    - 可丢失性。是否可以丢失。
    - 可恢复性。
- 数据同步。见上方
- 异常处理。多通道同步，不同的方式走不同的网络。mysql主从复制+消息队列
- 同步和访问结合。在访问的时候根据用户访问进行同步。（如 sessionID 最后携带了 regionID）

---

发送异常处理：
- 发送异常，重试
- 发到异常，持久化
- 消费异常，重发
