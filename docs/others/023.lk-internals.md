# livekit 内部原理

## 客户端协议

https://docs.livekit.io/reference/internals/client-protocol/

Basics

- LiveKit 客户端使用一个 WebSocket 基于 Protocal Buffer 和服务端进行通信。
- 客户端最多可以使用 WebRTC PeerConnection 与 SFUs 建立两个连接，分别用于发布和接收流。
- 用不同的 PeerConnection 收发流简化了协商过程，消除了协商炫光（Glares），发送 Track 的一方是初始化 Offer 方。

> WebRTC Signalling Glare
> 是指信令不协调、不同步，并且有可能导致最终处于不确定状态。
> 在 WebRTC 场景下发生的情况是：终端双方同时发起了会话协商。
> 有可能发生在初始化阶段，或者更新会话阶段。
> 解决方案是加入报价进行对比，价高者保留。

加入房间的流程

1. 加入房间时，客户端向服务端发送 `/rtc` 的 WS 连接
2. 服务端会发送一个 `JoinResponse` 包含了房间信息、参与者信息等
3. 服务端初始化 PeerConnection 向客户端发送 Offer
   1. 如果开启自动订阅，offer 将包含 room 中已存在的 Track
   2. offer 将包含两个 DataChannel
4. 客户端和服务端通过 Trickle ICE 交换候选者
5. 客户端收到 Offer，发送 Answer
6. ICE 连接建立
7. 服务端通知其他参与者有新参与者进来

`/rtc` 接口控制功能的参数

- access_token
- reconect: 是否恢复到一个已存在的连接，如果设置为 true 服务端在连接后将尝试 ICE 重启
- auto_subscribe: 默认 true，自动订阅房间中所有轨道
- sdk: 表示当前正在使用的 SDK（js, ios, android 等）
- protocol: 表示协议的版本（如 9）
- version: 表示客户端 SDK 的版本

Publish Track

要发布 Track，客户端必须先通知服务端并发送 Track 的 metadata。

1. 客户端发送 AddTrackRequest 并携带 metadata
2. 服务端返回 TrackPublishedResponse
3. 客户端添加一个 Transceiver 附带 media Track 到 PeerConnection
4. 客户端初始化 Offer 发到服务端
5. 服务端响应 Answer 并开始接收 Track
6. 判断是否服务端其他参与者订阅了此 Track，xxx（此话好像说了一半）

Receive Track

当有 Track Publish 的时候，服务端会发送 Track metadata 到 Room 中所有的参与者，然后将 Track 添加到每个订阅者的 PeerConnection 上

服务端事件

服务端将通知客户端如下事件，客户端需要幂等地进行处理。

- ParticipantUpdate，当其他参与者加入或退出房间时
- LeaveRequest：当让某个参与者立即离开时
- SpeakerChanged：当 Room 中活动的说话方变化时，服务端下发 SpeakerInfo 列表

客户端初始化控制

静音功能：WebRTC 本身不支持静音轨道，如果静音，Track 会发送空包，但服务端需要一个静音事件通知，以及抑制空包来优化网络消耗。

静音一个 Track 时，设置 `MediaStreamTrack.enabled = false` 然后下服务端发送 `MuteTrackRequest` 并携带对应 Track 的 Sid

改变流的质量

对于特定的客户端，`UpdateTrackSetting` 会通知服务端是否要临时暂停或者发送一个不同质量的 Track，对于大的 Room 是邮箱的。

订阅控制

客户端使用 `UpdateSubscription` 可以控制订阅哪个 Track

## MCU 和 SFU

WebRTC 是一种 P2P 协议，当两个对等连接建立后，他们直接互相交换媒体，在对等方少的时候可以很好的工作，但多了之后带宽就是个问题。

一个流行的解决模型是 MCU（Multipoint Conferencing Unit）架构，在 MCU 中，每一个会议中的用户发送媒体流（编码、压缩）到中央服务器（MCU）。

MCU 解压、解码每个流，并将他们按一定布局粘合在一起，如一行一行的磁贴网格，然后服务端向每个客户端发送这个复合的媒体流。

MCU 的限制因素在于，无法单独控制指定媒体的属性（如音量），以及需要在 UI 上妥协，并且中央服务器的服务配置需要很高。

Livekit 使用了另一种常见的客户端-服务端架构：Selective Forwarding Unit，选择性转发单元。

SFU 在收到媒体流后，将每个流的副本转发到订阅者，而无需做任何底层包处理（解压缩、解码）。

SFU 用下游带宽换取了灵活性和可扩展性，订阅者将单独拉取每个订阅的流并能完全单独控，服务端和客户端都可以根据订阅者的下行带宽自动调整 Track 的参数（分辨率、比特率等）。

LiveKit 的 SFU 是基于 Redis 保证加入房间的客户端都镰刀同一个节点的，如果使用单点模式则不需要依赖 Redis。
