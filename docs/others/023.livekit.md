# livekit

- [是什么](#是什么)
- [生态](#生态)
- [基础概念](#基础概念)
- [授权](#授权)
- [lk cli 的使用](#lk-cli-的使用)
- [SDK 的使用](#sdk-的使用)
  - [实时媒体的使用](#实时媒体的使用)
  - [实时文本和数据](#实时文本和数据)
  - [状态同步](#状态同步)
- [服务端 API](#服务端-api)
- [录音与合成](#录音与合成)
- [Ingress](#ingress)
- [自建 LiveKit](#自建-livekit)
  - [分布式模式，redis 是必要的，作为共享数据的存储和消息总线](#分布式模式redis-是必要的作为共享数据的存储和消息总线)
  - [多 Region 支持：](#多-region-支持)
  - [防火墙配置](#防火墙配置)
  - [Egress](#egress)
  - [Igress](#igress)
  - [SIP server](#sip-server)
- [LiveKit Agents](#livekit-agents)
- [对 kitt 的分析](#对-kitt-的分析)

## 是什么

开源框架，能快速集成 音视频、文本、数据、AI 模型，同时基于 WebRTC 可以提供可扩展的基础设施。

## 生态

- LiveKit Server: 可以自部署，可以使用云环境
- LiveKit SDKs
- LiveKit Agents
- Telephony
- Egress
- Ingress
- Server APIs

## 基础概念

- Room: 从参与者进来创建，最后一个离开后延时销毁。
- Participant: 参与者，一个用户或进程，有唯一 ID，包含状态和发布的 Tracks
  - 有一些内置的 Types:
    - STANDARD: 普通的终端用户
    - AGENT: 一个大模型
    - SIP: 电话接入用户
    - EGRESS: 一个服务端的用于录制 session 的进程
    - INGRESS: 一个服务端用于处理 入网媒体 的进程
- Track: 一条媒体流，每个参与者会发布 Track，和订阅其他人的 Track。每个 Track 有 TrackPublication 对象
  - TrackPublication: 当 Track 被订阅后，它将有一个 .track 属性关联对应的 Track 对象
  - 我们可以操作 Track

Room 中有多个 Participants，每个 Participant 可能 添加、删除、修改 Track 的状态，其他 Participant 收到状态的变化。

## 授权

- 要连接 LiveKit Server 都要进行授权。
- Token 是基于 JWT 签发的
- Token 包含了参与者 ID、Room 名称、权限和能力
- Token 包含过期时间，过期后无法初始化连接，但重连没有影响（具体点）
- Token 中包含了创建 Room 的配置信息

## lk cli 的使用

```sh
# 环境参数（需要总是携带）
lk --api-key one-fake-key --api-secret one-fake-secret --url http://localhost:7880
# or 用环境变量
export LIVEKIT_API_KEY=one-fake-key
export LIVEKIT_API_SECRET=one-fake-secret
export LIVEKIT_URL=http://localhost:7880

# 生成 token
lk token create --api-key one-fake-key --api-secret one-fake-secret --join --room test_room --identity test_user --valid-for 24h

# 加入房间，并生成模拟音视频流
lk room join --url ws://localhost:7880 --api-key one-fake-key --api-secret one-fake-secret --publish-demo --identity bot_user my_first_room

# 从模板库中初始化一个应用（lk app create 可以通过页面选择）
lk app create --template <template_name> my-app   # 可参考 https://github.com/livekit-examples/index?tab=readme-ov-file
```

## SDK 的使用

- livekit 提供了多种 SDK，有前端的、后端的，以及 UI 的，参考 https://docs.livekit.io/reference/
- room 是按名称做 ID 的，每个参与者的 identity 也必须唯一。
- 连接到 Room 必须两个参数，wsUrl 和 token（JS 代码 `const room = newRoom(); await room.connect(wsUrl,token);`
- Room 连接成功，对象将包含两个关键属性 `localParticipant` 和 `remoteParticipants` 分别表示当前用户和其他参与者
- Room 连接成功后，可以 **publish** 和 **subscribe** 实时媒体 Tracks 或和其他参与者 **交换数据**（发送文本、文件、RPC 等）
- LiveKit 通过事件通知变更，有两种事件 Room 事件和 Participant 事件。有些同一个事件会在两者上发生
- 离开 Room 需要调用 `Room.disconnect()`，如果应用终止而未调用此方法，参与者会在 15s （一些平台会在应用终止时自动调用）
- 断开 Room 连接时，部分场景下会有 Reason 值表示原因
- 连接的可靠性保障（按顺序）：基于 UDP 的 ICE、基于 UDP 的 TURN、基于 TCP 的 ICE、基于 TLS 的 TURN。
- 网络变更和重连：lk 会自动尝试 ICE 重启恢复连接，重连后会恢复媒体通信；如果 ICE 重启失败，lk 会执行一个完整的重连（花费更长时间），会触发一系列 Reconnect 事件

> [ICE restart](https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Session_lifetime#ice_restart)

### 实时媒体的使用

LK 可以做什么，主要是基于语音传输和视频传输玩出花儿来：

- AI 语音坐席：AI 机器人语音服务客户
- 视频会议：每个用户发布自己的声音、视频，窗格展示
- 直播场景：一个播放者和大量观众
- AI 视频监控：每个 Room 有多方发布视频，AI 监控这些视频提供告警等

使用麦克风和摄像头：

- 获取设备权限：浏览器在使用时候自动弹出，一些设备需要配置及使用前申请
- 发布音视频：`room.localParticipant.setCamraEnabled(true); room.localParticipant.setMicrophoneEnabled(true)`
- 静音、接触静音，触发 TrackMuted 事件给当前 Room 所有参与者
- Track 权限控制：发布者可以控制自己的 Track 可以被谁订阅
- 从后端服务中发布 Track：有诸多 SDKs 及 CLI
- 发布 audio track：创建一个 AudioSource 发布 Track，如正弦波
- 发布 video track：lk 可以自动转码
- 音视频的同步问题：会自动同步，有时候需要手动同步，用到 AVSynchronizer 工具

屏幕共享：

- `await room.localParticipant.setScreenShareEnabled(true)`
- 分享浏览器声音（仅部分浏览器支持）：`const tracks = await localParticipant.createScreenTracks({audio: ture}); tracks.forEach((track) => {localParticipant.publishTrack(track)})`

订阅 Track：

- 两个对象：TrackPublication 是一些元信息；Track 是媒体流本身
- 媒体播放：一旦订阅 audio/video track，就准备好了播放
- 音量控制：范围 0-1.0
- 说话人识别：lk 能自动检测谁在说话，说话状态变化时发送更新（事件），你可以在 UI 上进行控制显示
- 选择性订阅：禁用默认的自动订阅后可以手动控制订阅，这提供了更精细的订阅控制（SDK 和 API 都支持控制）
- 自适应流：控制流传输的分辨率，根据窗格大小自动控制流传输甚至隐藏后自动暂停传输
- 启用/关停 Track：订阅者关闭接收发布者的媒体流，这可以优化订阅者的带宽。和选择性订阅的不同在于协商握手部分，直接关停不会协商。
- 联播控制：接收端根据自己的情况（网络、硬件状况等）动态选择接受质量

噪音和回声消除：

- WebRTC 自带有此两个功能，MediaTrackSettings 的两个属性：echoCancellation, noiseSuppression [参考](https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/echoCancellation)
- 背景：麦克风可能收集环境噪音或扬声器中的回声，干扰语音识别质量，影响体验
- lk 集成了开源 WebRTC 实现的噪音和回声消除功能，可以调整设置启用

端到端加密

- E2EE，End-to-end encryption
- lk 内置支持媒体流的端到端加密，确保了包含 lk 自己在内的中间人不可以修改其内容
- 工作原理：在 Room 级别自动应用到所有 Track 上，内置密钥是整个 room 共享的单个密钥，如果要实现每个参与者密钥不同需要自己实现
- 开发者自己需要生成、存储、分发密钥给应用，lk 不会负责
- 如果用共享密钥，开发者需要在 room 创建时在 server 端生成，并安全地分发到用户 token 中
- 如果每个参与者的密钥不同，注意每个参与者要有所有参与者的密钥（加解密每个 track）
- 限制：所有 lk 网络通过 TLS 加密，端到端加密值用于媒体 Track，不会用于实时数据、文本、API 调用 或其他信号
- 使用：omitted

编解码等高级音视频问题

- lk 支持多个 Video Codec：H.264、VP8、VP9、AV1
- Video Track 配置：包含两部分，Capture Setting 和 Publish Setting
- 视频联播：可以发布同一个 track 的不同比特率的版本，允许 lk 根据接收方动态控制转发流
- 动态广播：如果订阅者不再消费，会自动暂停视频的发布
- HiFi audio：lk 支持配置

### 实时文本和数据

- 参与者可以交换文本、文件或自定义数据

发送文本：

- Text Stream
- 每个 Text Stream 关联一个 topic，你需要在 topic 上注册一个回调接受文本流
- 流的目标可能是指定的参与者，也可以是整个 Room
- 一次发送：`sendText()`，不用考虑文本太大，会分块
- Stream 形式发送：`streamText()`，适用于文本动态生成的场景，注意关闭
- 处理收到的流（回调）：`room.registerTextStreamHandler('my-topic', (reader, participantInfo) => {}`
- 流的属性，其中一项是 destinationIdentities 数组，谁能接收 stream，默认所有
- 并发性：支持并发，读写都支持
- 发送流的中途进入房间：不会收到此流，只有在流开始传输时参与者连接上才能接收
- lk 不会做文本持久化，需要开发者自己实现

发送二进制数据

- Byte Stream
- 每个 Byte Stream 有一个关联的 toic，必须注册回调实现接收
- 发送文件： `room.localParticipant.sendFile(FileURL, for: "my-topic")`
- 流式发送二进制数据：注意关闭
- 处理 incoming 的流：上面两种发送方式对应此一个接受方式
- 其他于发送文本一致
- 接收和发送保证是最终一致

RPC

- 使用 RPC 在 Room 其他参与者身上执行自定义方法并等待响应
- 用于请求数据、指定应用状态等场景：如请求用户的实时位置
- 目标参与者（远程）需要注册一个函数 `localParticipant.registerRpcMethod("NAME") {}`
- 调用远程函数：`localParticipant.performRpc(destinationIdentity: "ID", method: "NAME", payload: "DATA")`
- RPC 输入和输出的参数都只支持 string 格式，可以是 JSON 的或 base64 编码的
- RPC 默认 10s 超时，可以更改
- RPC 可以抛 Error 或返回自定义 Error

数据包

- 这是低层次的 API，用于高频的使用或高级用法
- 两个函数：`localParticipant.publishData, room.SendData`
- lk 提供了两种形式的包发送方式：Reliable 和 Lossy 的
- 数据包大小限制：Reliable 下是每个包 15KB（协议限制包是 16K，lk 加了些头导致降低）；Lossy 模式下建议最大是 1300B

### 状态同步

lk 有多种方法用于 Room 内的状态同步，状态主要有两个存储：Participant 和 Room

Participant 的属性

- 每个 Participant 有两个属性存储应用状态：attributes (k-v string) 和 metadata (string)
- 这些数据有 lk server 维护，会对每个参与者添加属性
- 初始化的 value 被设置在 token 中
- 删除属性直接置空即可
- 更新频率：高并发下不合适频繁更新，频繁更新场景考虑使用 发送数据包
- 大小限制：两个属性最大 64K
- Participant 必须要有 `canUpdateOwnMetadata` 权限才能更新自己的属性
- 在服务端，可以使用 `room.UpdateParticipant` API 更新任何参与者的属性

Room metadata

- 所有 Participants 共享特定的的应用数据
- Room metadata 只能由服务端 API 设置，可以被所有参与者访问
- 设置方法：`CreateRoom, UpdateRoomMetadata`
- 订阅更新：订阅 `RoomMetadataChanged` 事件

处理事件

- lk SDK 用事件进行交互 Room 的变化
- 两类事件：Room 事件 和 Participant 事件
- Room 事件从主 Room 对象中触发，表示 Room 中的变化；Participant 事件来自每个 Participant
- 有些事件会同时在 Room 和 Participant 对象上触发，这是故意这样设计的
- 声明式 UI：lk 内置的支持 声明式 UI，你可以直接指定期望的 UI 状态，不需要考略状态变化的顺序。现代框架对检测变化和渲染很高效
- 指定平台的快速入门（略）

> 声明式（Declarative），对应是 指示式（Imperative），React 就是一种声明式 UI 的理念。
> 指示式 UI 是指你需要按部就班地进行编程 UI 的变化过程。A(UI) -> B(UI) -> C(UI)
> 声明式 UI 是指描述你最终期望的状态，通过状态展示 UI。A(UI), B(UI), C(UI)，which to set?

## 服务端 API

- 生成 token
- room 管理：需要先初始化一个 room client，通过 roomClient 查询 Room
- participant 管理：需要先初始化一个 room client，通过 roomClient 查询 Room 中的参与者
- webhook：需要在 lk 服务端配置（config 文件中的 webhook 部分）：需要配置 api_key 和一个 urls 列表，api_key 用于签名，必须是 lk 配置中的一个
  - 使用 HTTP POST 请求触发，JSON 格式传输，`Content-Type: aplication/webhook+json`
  - lk 通过 Authorization 头携带 JWT token，包含了 body 的 sha256 哈希值（用于校验）
  - lk 服务端 SDK webhook 库已经集成了鉴权验证和 payload 的解析（go SDK 中校验错误会通过 err 返回）
- webhook 的发送和重试：lk 会重试多次，lk 会对事件进行正确的排序，只有旧事件最终成功或重试多次丢弃后才会触发下一个事件
- 事件：所有的事件一定携带三个字段 id(UUID), createdAt(UNIX timstamp in sec)

## 录音与合成

- 使用 lk 的 Egress 服务录音或直播一个房间。
- Egress 提供了一系列 API 可以导出 room 或任何 track
- 支持记录 MP4 或 HLS 段，以及到处到直播平台
- Egress 是独立的组件需要部署
- Egress 有多种类型：
  - Room Composite Egress: 导出整个房间的 video/audio，使用 Chrome web layout 渲染，复合模板可以自定义。
  - Web Egress: 和 Room Composite 类似，允许到处任何 web page，但没有和 room 绑定
  - Participant Egress: 导出一个参与者的音视频
  - Track Composite Egress: 同步并导出一个 audio 和一个 video 流，会转码和合并。
  - Track Egress: 直接导出单个 track，video 的不会转码
- 服务架构

> HLS, Http Live Streaming, HTTP 实时流

## Ingress

使用 Ingress 服务可以将一个 非 WebRTC 的源 直播到 LK room 中。

- 流程：
  - app 使用 CreateIngress API 创建一个 Ingress，返回一个 URL 和 流密钥
  - 你的用户复制粘贴 URL 和 密钥 到 streaming workflow 中
  - 你的用户开始他们的直播流
  - The Ingress 开始转码他们的流，或转码关闭时直接转发媒体
  - The Ingress Server 加入到 room 中并发布媒体给其他成员
  - The Ingress 一直有效，在 disconnected 状态下允许使用相同的 流密钥 重用它

## 自建 LiveKit

- 自签证书无法使用，证书必须要用可信的证书机构颁发
- 内置了 TURN 服务，集成了 lk 的授权机制
- 生产环境建议用 --config 指定配置文件。另外可以将 YAML 配置文件的内容通过 LIVEKIT_CONFIG 环境变量传入（配置文件样例）
- 资源：生产环境建议 10G 以上的以太网带宽或更高
- 默认这些端口：
  - 443: 主要的 HTTPS、TURN/TLS  入口
  - 80： TLS 颁发
  - 7881: WebRTC over TCP
  - 3478/UDP：TRUN/UDP
  - 50000 - 60000/UDP，WebRTC over UDP
  - 1935: RTMP Ingress（启用 Ingress 的时候需要）
  - 7885/UDP: WebRTC for WHIP Ingress
- 服务器启动，在网络可用前启动服务实例，可能导致云的 init 脚本阻塞，如果发生 重启

### 分布式模式，redis 是必要的，作为共享数据的存储和消息总线

- 当 redis 配置了，lk 自动转成分布式设置，即使用了 redis 存储 room 数据和消息总线
- 分布式模式下，每个节点定期上报状态到 redis，可以用于查看整个集群状态及路由决策
- 当 client 创建一个连接到 lk，则它创建了一个 持久的 WebSocket 到某一个实例
- 缩容的处理：
  - 当收到终止请求时（SIGTERM、SIGINT、SIGQUIT），节点会进入 Draining 模式，此模式下活动的 room 不受影响，但无法创建新 room，所有参与中断开连接后，服务退出

### 多 Region 支持：

- 可以部署多个数据中心，允许用户在不同的区域连接到最近的节点
- 这样工作：
  - DNS Server 返回最近的负载均衡 IP
  - 用户连接这个 IP
  - 用户连接到这个 region 的一个 lk 实例
  - 如果 room 不存在，使用 node selector 去选择可用 node（选择策略）

### 防火墙配置

| def port    | protocol       | config                                   | use                                                                              |
| ----------- | -------------- | ---------------------------------------- | -------------------------------------------------------------------------------- |
| 7880        | API, WebSocket | port                                     | lk 服务 API 主端口（应该放在卸载 SSL 的负载均衡器后面）                          |
| 50000-60000 | ICE/UDP        | rtc.port_range_start, rtc.port_range_end | WebRTC host candidates （每个参与者使用两个端口）                                |
| 7881        | ICE/TCP        | rtc.tcp_port                             | 当客户端无法使用 UDP 的时候使用                                                  |
| 7882        | ICE/UDP Mux    | rtc.udp_port                             | （可选）当使用此配置后，上方 UDP 返回不会被用到，所有 UDP 数据都会从这个端口交互 |
| 5349        | TURN/TLS       | turn.tls_port                            | （可选）负载均衡需要在前面，如果没有负载均衡，此端口需要是 443 端口              |
| 3478        | TURN/UDP       | turn.udp_port                            | （可选）TURN 的                                                                  |
| 5060        | SIP/UDP+TCP    | sip_port                                 | （可选）用于 SIP 对接                                                            |
| 5061        | SIP/TLS        | tls.port                                 | （可选）用于 SIP 对接                                                            |
| 10000-20000 | SIP RTP/UDP    | rtp_port                                 | （可选）用于 SIP 对接的 RTP 端口                                                      |


### Egress

### Igress

### SIP server

- 安装 SIP Server
- 配置 config.file
- 启动 `livekit-sip --config=config.yaml`
- 确定 SIP URI（PUB_IP:5060）

## LiveKit Agents

https://docs.livekit.io/agents/start/voice-ai/

## 对 kitt 的分析

kitt 实现了什么？

[kitt](https://github.com/livekit-examples/kitt) 中用 Go 实现了后端和 ChatGPT 进行对接，然后服务于用户，可以在 [这里 Try...](https://kitt.livekit.io/)

注意，这里实现的后端相当于一个 Agent，而不是前端用户的一个代理，因为他有自己的 ID 表示并 Join 了 Room，因此里面提到的 RemoteXXX 是用户的资源。

怎么实现的？

1. 在 Handler 中先创建 lk token
2. 然后调用 `lk.ConnectToRoomWithToken()` 并设置了多个回调，回调有 room 级别的有参与者级别的
3. 然后生成了一个 track = `lksdk.NewLocalSampleTrack(conf)`，生成即触发 `track.StartWrite()` 不过 provider 是空的
4. 然后用 `LocalParticipant.PublishTrack` 本 track，LocalP 就在 Room 身上
5. 最后在 p 上注册了回调 `OnDisconnected()`

回调是关键，有如下几个：
- Participant 级别的 OnTrackPublished, OnTrackSubscribed, OnTrackUnsubscribed 传入的参数是远程 publication 和 远程的 participant
  - `OnTrackPublished`: publication 的来源不是麦克风，不处理；是麦克风将 publication 设置为订阅的
  - `OnTrackSubscribed`:
    - 新建了一个自定义的 `Transcriber`，将 `track.Codec()` 传进去以及一个 asr cli 传进去，后台运行起来，看来是异步进行识别；
    - 然后又异步起来一个获取结果的，获取结果后用 `p.room.LocalParticipant.PublishData()` 发布出去（发到前端用户展示转写的文本）
    - 然后还有一个异步，将 `track.ReadRTP()` 直接转发到 `transcriber.WriteRTP()`
  - `OnTrackUnsubscribed`
    - 关闭 `transcriber`
- Room 级别的 OnParticipantDisconnected, OnDisconnected，两个都是关闭资源

问大模型得到的答案（媒体接收的完整流程）：

- 1. 前端 通过 LiveKit React 组件连接到 LiveKit 服务器，自动发布音频/视频流
- 2. 后端 通过 LiveKit SDK 连接到同一个房间
- 3. 后端 监听 OnTrackPublished 事件，当检测到麦克风音频流时自动订阅
- 4. 后端 在 trackSubscribed 回调中创建 Transcriber 实例
- 5. 后端 持续读取 RTP 音频包，转换为 OGG 格式后发送给 Google Speech-to-Text
- 6. 后端 接收转文字结果，通过数据通道发送给前端显示

流程中，
- 第1点，前端是直接发到 livekit 服务器吗？。<font color="red">是的</font>
- 第3点，监听 `OnTrackPublished` 是谁的 Track 在 Publish，是连接过来的前端用户吗？<font color=red>是的，前端用户的 Track</font>
- 第5点，读出的 RTP 音频包，是这个前端用户的吗？<font color=red>是的，读出的 RTP 音频包是前端用户的</font>
