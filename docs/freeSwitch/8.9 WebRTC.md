# WebRTC

https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API

[webrtc 开源](https://webrtc.github.io/samples/)

- WebRTC 由一套 API 和协议组成。
- WebRTC API 组成部分：
  - **设置和管理连接**部分，包含接口、事件、类型
  - **身份和安全**的 API：用于管理用户身份和安全性认证
  - **电话**相关接口、事件
  - **编码转换**相关接口和事件
- **WebRTC 协议** 中包含如下概念
  - ICE，交互式连接创建，是允许浏览器和浏览器之间建立连接的一个协议框架，主要解决防火墙、路由器限制等问题。工作在本地底层，通过事件通知到上层应用层。
  - STUN，NAT 下会话穿越工具，让 NAT 下的客户端通过公网中的 STUN 服务器获取到自查的公网地址，进行对外交互
  - NAT（解释略），一些路由器严格限定了谁能连接 NAT 下的设备（如对称型 NAT），这种情况下 STUN 识别了内网设备的公网 IP 和端口的映射也无法和内网设备建立连接，这时就要转向 TURN 协议
  - TURN，通过 TURN 服务器中继所有交互数据，以此来绕过对称型 NAT
  - SDP，会话描述协议，是描述多媒体连接内容格式的，略。
- RTP
  - 实际用的是 SRTP，Secure RTC
  - 和 RTCP 关联存在
  - 低延迟
  - 不保证顺序。但包含序列号和时间戳，接收方可以重组
  - 必须搭建在 UDP 之上
  - 不仅限于音视频通信，可以传输任何数据
  - 不保证服务质量（QoS），由 RTCP 控制
  - 不保证资源的分配和预留
- RTCPeerConnection 和 RTP
  - RTCPeerConnection 提供了 RTP 交互的一套方法
  - 有三种类型的传输
    - RTCRtpSender 处理本地 MediaStreamTrack 的数据编码，并发送到对方
    - RTCRtpReceiver 提供检查和获取远端 MediaStreamTrack 的数据
    - RTCRtpTranseiver 是一对 RTC Sender 和 Receiver 共享的双向的 RTP（SDP 中有共同的 mid 行）
  - 一个 hold 功能的例子
    - 功能：关闭麦克风、发送音乐到对端、停止接受对端的音频
    - 本端
      - `await audioTransceiver.sender.replaceTrack(audioStream.getAudioTracks()[0])` 替换发送的媒体
      - `audioTransceiver.receiver.track.enabled = false;` 禁用传入音轨
      - `audioTransceiver.direction = "sendonly";` 改成只发模式
      - 如上会触发 RTCPeerConnection 的重协商（发送 `negotiationneeded` 事件），你的代码需要生成 SDP 并使用 `RTCPeerConnection.createOffer()` 发送到远端
      - `audioStream` 参数包含了播放的音频流，可以来自于任何地方，比如浏览器使用 `HTMLAudioElement.captureStream()` 捕获的音频流
    - 远端
      - 当收到 `sendonly` 的 SDP 后，用如下步骤方法接受 SDP 协商
      - `await peerConnection.setRemoteDescription(offer);` 设置远端 SDP
      - `await audioTransceiver.sender.replaceTrack(null);` 停止发送媒体
      - `audioTransceiver.direction = "recvonly";` 设置为 只续保
      - `await sendAnswer();` 发送 SDP 响应（这个方法使用 `createAnswer()` 生成应答）

## WebRTC 的连接

- WebRTC 的连接
  - 信令通道（或信令服务，Signaling Channel，Signaling Server），用于交换对等双方的 SDP 信息
  - A 将初始化连接，创建 Offer，然后使用信令通道发送到 B；B 收到 Offer 后创建 Answer，然后通过信令通道发回给 A
  - 具体步骤
    - 主叫通过 `MediaDevices.getUserMedia` 获取本地媒体
    - 主叫创建 `RTCPeerConnection` 并调用 `RTCPeerConnection.addTrack()`
    - 主叫通过 `RTCPeerConnection.createOffer()` 创建 Offer
    - 主叫调用 `RTCPeerConnection.setLocalDescription()` 设置本地 Offer
    - 这时，主叫会询问 STUN 服务生成 ICE Candidates
    - 主叫会通过信令通道传输 Offer 到被叫方
    - 被叫收到 Offer 调用 `RTCPeerConnection.setRemoteDescription()` 记录远端 SDP
    - 被叫做一些设置，如捕获本地媒体、通过 `RTCPeerConnection.addTrack()` 绑定
    - 被叫通过 `RTCPeerConnection.createAnswer()` 创建 Answer
    - 被叫调用 `RTCPeerConnection.setLocalDescription()` 传入 Answer 为本地 SDP
    - 这时，被叫使用信令服务传输 Answer 到主叫
    - 主叫收到 Answer
    - 主叫调用 `RTCPeerConnection.setRemoteDescription()` 设置 Answer 为远端 SDP
    - 媒体开始按配置进行传输
  - pending 和 current SDP
    - 由于有重协商以及协商可能被拒绝，所有有这两种不同状态的 SDP 信息
    - current SDP 表示连接真实在使用的: `RTCPeerConnection.currentLocalDescription`, `RTCPeerConnection.currentRemoteDescription`
    - pending SDP 表示正在协商中的：`RTCPeerConnection.pendingLocalDescription`, `RTCPeerConnection.pendingRemoteDescription`
    - `RTCPeerConnection.localDescription` 和 `RTCPeerConnection.remoteDescription` 优先返回 pending 的，若不存在则返回 current 的
    - `RTCPeerConnection.setLocalDescription` 和 `RTCPeerConnection.setRemoteDescription` 会设置我 pending 的，WebRTC 层会评估是否接受，一旦接受会变成 current 的，并将 pending 的设置为 null
  - ICE 候选
    - 用 SDP 交换媒体之外，对等连接必须交换网络连接信息，这就是 ICE 候选
    - 通常优先使用 UDP，但不是所有浏览器支持 TCP 的 ICE
    - 选择候选对儿
      - ICE 层会选择两方中一个做 *控制代理*（Controlling Agent），另一方叫 *受控代理*（Controlled Agent），可以通过 `RTCIceCadidate.transport.role` 来判断角色
      - *控制代理* 会决定哪一个候选对用于连接，必要时还会使用 STUN 和更新的 Offer 项
      - *受控代理* 仅仅等待被告知哪个候选对被使用
      - 单个 ICE 会话可能引发控制代理选择多个候选对，每次都会和受控代理共享这个信息，双方会重新配置连接使用新候选对
      - ICE 会话完成后，当前有效的配置就是最终配置，除非发生 ICE 重置
      - 为了通知远端，候选者应该用 `addIceCandidate()` 方法添加到连接中
      - 每次候选结束，一个 end-of-candidates 通知用 RTCIceCandidate 的形式发出，其 candidate 属性是空，可以通过监听 `iceGatheringState` 改为 `complete` 或 `icegatheringstatechange` 事件检测到
    - 当事情发生错误时
      - ICE Rollback，恢复上次的 SDP Offer
      - 程序中回滚只需要发送一个 type 是 `rollback` 的描述即可，其他字段将被忽略
      - ICE 重启
- WebRTC 完美协商模式
  - 协商本质不对称——一方是发起者，另一方是被动接受者。完美协商模式通过将这种差异分离到独立的协商逻辑中来消除，因此你无需再关心连接的是哪一端，双方使用相同的代码
  - 工作原理：协商过程中为两个对等网络各分配一个角色，一个是 polite 的，一个是 impolite 的（礼貌的和无力的），在发生冲突时 polite 的总是让步，impolite 的不会让步
  - 这里就需要协商谁是 polite 的谁是 impolite 的，可以通过交换数字决定，也或者就用先联系信令服务器者为 polite 的，开发者可自行决定

> 对 **信令服务器** 的理解：
> 所说的信令服务器，也可以是业务服务器，这是按场景区分的。
> 如果服务器只做信令的协商，目的是为了让不同的客户端之间直接通信，即媒体流不经过本服务器，那么就是单纯的信令服务器；
> 如果服务器作为对等连接中的一方和多个客户端进行连接，通常这种场景要在服务端做媒体录制、自定义媒体交互等工作，这也是信令服务器，只不过同时兼具了业务服务器的角色。

> 用 **WebSocket 服务器实现信令服务器** 的理解：
> 文档中多次提到可以用任何协议来实现信令服务器 Websocket 或 XMLHttpRequest 等。一句话来说明信令服务器就是来传递信息的，但传递的是什么不关心，能传递就能做信令服务器
> 用 WebSocket 做信令服务器的步骤是这样的：
> 1. 每个 Peer 通过 WebSocket 连接服务器，并告知相同的 *会话令牌*（RoomID 等）
> 2. 发起方创建 RTPPeerConnection 对象，调用 `createOffer()` 生成 SDP Offer，通过 WS 传递给服务器（SDP 格式自行约定即可）
> 3. 服务器将发起方的 SDP 转发给接收方
> 4. 接收方通过 WS 收到 SDP Offer 后保存，并生成 SDP Answer，通过 WS 回传给服务端
> 5. WS 服务器将接收方的 SDP 再转发给发送方（完成 SDP 交换）
> 6. 双方创建 RTCPeerConnection 后，会自动收集 ICE 候选者，通过 WS 转发，完成连接路由信息的交换
> 7. 双方完成 SDP 协商和 ICE 候选者交换后，会自动创建 P2P 连接，此时媒体直接在客户端之间传输，不再需要 WS 服务器

> **SDP 和 Candidate 分开传输还是在一起传输**
> SDP 是描述设备的媒体能力（如支持的编解码器、分辨率、传输协议等）和会话的基本信息（网络地址类型、会话标识等）
> ICE Candidate 是网络连接信息（IP、端口、传输协议等），用于确定点对点的实际路由
> WebRTC 中是分开传输的，分开传输的原因：一般 SDP 是主动创建的（立即生成），而 ICE Candidate 需要设备不断探测网络逐步生成（一般是异步生成，可以是多个），这叫 `trickle ICE` 技术
> 而在 SIP 协议结合 WebRTC 常见做法是在 SDP 中携带 ICE Candidate

![webrtc 连接过程](/assets/webrtc-sdp.drawio.png)

## WebRTC 的 DataChannel

- 所有 WebRTC 组件都是加密的，因此 DataChannel 也是基于 DTLS（数据包传输安全）安全传输的
- 调用 `pc.createDataChannel("ID")` 会和对端自动协商创建一个 DC 通道
- 手动协商需传入参数 `let dc = pc.createDataChannel("ID", { negotiated: true })` 然后用 `requestRemoteChannel(dc.id)` 来触发协商
- 手动协商可以传递一些属性，如 ID，实现多个通道的精细化控制；也可以修改协商参数（最大重传次数、是否有序等）
- 传输大小受限于用在 RTCDataChannel 上传输数据的协议 SCTP（流控制传输协议）。传输最好小于 16KB
