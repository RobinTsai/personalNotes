# socat

## SendFile

### 方案一：简单 UDP 传输（可能丢包）

```sh
# server: receive file via udp port (先启动)
socat -u UDP4-LISTEN:8888 OPEN:received_file.txt,creat,trunc
```

```sh
# client: send file via udp port
socat -u OPEN:file.txt UDP4:192.168.1.100:8888
```

**注意**：此方案简单但不可靠，UDP 可能丢包或乱序。

### 方案二：可靠 UDP 传输（支持二进制文件）

**服务端脚本** `udp_recv.sh`:

```bash
#!/bin/bash
# UDP 文件接收服务端（支持二进制文件）
PORT=${1:-8888}
OUTPUT_FILE=${2:-received_file.bin}
ACK_PORT=$((PORT + 1000))

echo "Starting UDP receiver on port $PORT..."
echo "Output file: $OUTPUT_FILE"

# 临时目录存储接收的数据块
TEMP_DIR=$(mktemp -d)
trap "rm -rf $TEMP_DIR" EXIT

# 启动 ACK 发送进程
mkfifo "$TEMP_DIR/ack_fifo"
(
    while read -r ack_msg; do
        IFS='|' read -r client_ip client_port <<< "$ack_msg"
        echo "ACK" | socat - UDP4:$client_ip:$client_port
    done < "$TEMP_DIR/ack_fifo"
) &
ACK_PID=$!

# 接收数据
expected_seq=0
while true; do
    # 接收一个 UDP 包
    data=$(socat -t 60 UDP4-LISTEN:$PORT,reuseaddr -)

    if [[ -z "$data" ]]; then
        echo "[TIMEOUT] No data received"
        break
    fi

    # 解析数据包: SEQ|BASE64_DATA|MD5
    IFS='|' read -r seq_num b64_data expected_md5 <<< "$data"

    if [[ "$seq_num" == "EOF" ]]; then
        echo "[DONE] Transfer complete, assembling file..."

        # 按序合并所有块
        > "$OUTPUT_FILE"
        for ((i=0; i<expected_seq; i++)); do
            if [[ -f "$TEMP_DIR/chunk_$i" ]]; then
                cat "$TEMP_DIR/chunk_$i" >> "$OUTPUT_FILE"
            else
                echo "[ERROR] Missing chunk $i"
                exit 1
            fi
        done

        echo "File saved to $OUTPUT_FILE"
        echo "Final MD5: $(md5sum "$OUTPUT_FILE" | cut -d' ' -f1)"

        # 发送最终 ACK
        echo "$(echo "$data" | socat -t 1 UDP4-LISTEN:$PORT -)ACK" > /dev/null 2>&1
        break
    fi

    # 验证 MD5
    actual_md5=$(echo -n "$b64_data" | md5sum | cut -d' ' -f1)

    if [[ "$actual_md5" == "$expected_md5" ]]; then
        # 解码并保存数据块
        echo "$b64_data" | base64 -d > "$TEMP_DIR/chunk_$seq_num"
        echo "[OK] Received chunk $seq_num ($(stat -f%z "$TEMP_DIR/chunk_$seq_num" 2>/dev/null || stat -c%s "$TEMP_DIR/chunk_$seq_num") bytes)"

        if [[ $seq_num -eq $expected_seq ]]; then
            expected_seq=$((expected_seq + 1))
        fi

        # 发送 ACK (简化版本)
        echo "ACK|$seq_num" | socat - UDP4:localhost:$ACK_PORT 2>/dev/null &
    else
        echo "[ERROR] Checksum failed for chunk $seq_num"
    fi
done

kill $ACK_PID 2>/dev/null
```

**客户端脚本** `udp_send.sh`:

```bash
#!/bin/bash
# UDP 文件发送客户端（支持二进制文件）
SERVER=$1
PORT=$2
FILE=$3

if [[ -z "$SERVER" || -z "$PORT" || -z "$FILE" ]]; then
    echo "Usage: $0 <server_ip> <port> <file>"
    exit 1
fi

if [[ ! -f "$FILE" ]]; then
    echo "File not found: $FILE"
    exit 1
fi

echo "Sending $FILE to $SERVER:$PORT"
echo "File size: $(stat -f%z "$FILE" 2>/dev/null || stat -c%s "$FILE") bytes"
echo "Original MD5: $(md5sum "$FILE" | cut -d' ' -f1)"

# 每个 UDP 包的数据大小（字节）
# base64 编码后会增大 1.33 倍，所以原始数据取 1024 字节
CHUNK_SIZE=1024
TIMEOUT=2
MAX_RETRIES=3
FILE_SIZE=$(stat -f%z "$FILE" 2>/dev/null || stat -c%s "$FILE")
TOTAL_CHUNKS=$(( (FILE_SIZE + CHUNK_SIZE - 1) / CHUNK_SIZE ))

echo "Total chunks to send: $TOTAL_CHUNKS"

SEQ=0
offset=0

# 按固定字节数读取文件
while [[ $offset -lt $FILE_SIZE ]]; do
    # 读取一块数据
    chunk=$(dd if="$FILE" bs=1 skip=$offset count=$CHUNK_SIZE 2>/dev/null | base64 -w 0)

    if [[ -z "$chunk" ]]; then
        break
    fi

    # 计算 base64 数据的 MD5
    md5=$(echo -n "$chunk" | md5sum | cut -d' ' -f1)

    # 发送数据包格式: SEQ|BASE64_DATA|MD5
    packet="${SEQ}|${chunk}|${md5}"

    retries=0
    success=false

    while [[ $retries -lt $MAX_RETRIES ]]; do
        # 发送数据包
        echo "$packet" | socat - UDP4:$SERVER:$PORT

        # 等待 ACK
        ack=$(timeout $TIMEOUT socat -t $TIMEOUT UDP4-LISTEN:$PORT,reuseaddr - 2>/dev/null)

        if [[ $ack =~ ACK ]]; then
            echo "[OK] Chunk $SEQ/$TOTAL_CHUNKS acknowledged"
            success=true
            break
        else
            retries=$((retries+1))
            echo "[RETRY] Chunk $SEQ (attempt $retries/$MAX_RETRIES)"
            sleep 0.1
        fi
    done

    if [[ "$success" == "false" ]]; then
        echo "[FAILED] Could not send chunk $SEQ after $MAX_RETRIES attempts"
        exit 1
    fi

    SEQ=$((SEQ + 1))
    offset=$((offset + CHUNK_SIZE))
done

# 发送 EOF 标记
echo "Sending EOF marker..."
for ((i=0; i<3; i++)); do
    echo "EOF||" | socat - UDP4:$SERVER:$PORT
    sleep 0.2
done

echo "[DONE] File transfer completed: $SEQ chunks sent"
```

### 方案三：使用 base64 编码的块传输

**服务端** `udp_recv_base64.sh`:

```bash
#!/bin/bash
PORT=${1:-8888}
OUTPUT=${2:-received.bin}

echo "Listening on UDP port $PORT..."

# 接收并重组
socat UDP4-LISTEN:$PORT,fork - | while read -r chunk; do
    echo "$chunk"
done | base64 -d > "$OUTPUT"

echo "File saved to $OUTPUT"
md5sum "$OUTPUT"
```

**客户端** `udp_send_base64.sh`:

```bash
#!/bin/bash
SERVER=$1
PORT=$2
FILE=$3

if [[ ! -f "$FILE" ]]; then
    echo "Usage: $0 <server> <port> <file>"
    exit 1
fi

echo "Sending $FILE to $SERVER:$PORT"
echo "Original MD5: $(md5sum $FILE)"

# 将文件转为 base64 并分块发送
base64 "$FILE" | fold -w 1400 | while read -r line; do
    echo "$line" | socat - UDP4:$SERVER:$PORT
    sleep 0.01  # 避免发送过快导致丢包
done

echo "Transfer complete"
```

## 使用说明

### 注意事项

1. **MTU 限制**: UDP 数据包大小建议不超过 1472 字节（1500 MTU - 28 字节头部）
2. **丢包问题**: UDP 不保证送达，大文件传输建议使用方案二或改用 TCP
3. **顺序问题**: UDP 不保证顺序，需要应用层处理
4. **流量控制**: 发送端加 `sleep` 避免接收端缓冲区溢出

### 推荐使用

- **小文件/内网**: 方案一（简单快速）
- **重要文件**: 方案二（带确认机制）
- **二进制文件**: 方案三（base64 编码）
- **生产环境**: 建议使用 TCP 或 rsync
