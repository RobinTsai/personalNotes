# 复制

命令

```go
// 建立复制
slaveof {masterHost} {masterPort}
// 查看复制状态
info replication
// 断开复制，并成为主节点（不会丢失数据）
slaveof no one
```

注意：切主操作（从复制一个主切换到复制另一个主）会清空原数据。

从节点默认为只读模式 `slave-read-only=yes`，建议不要动。

## 拓扑

- 一主一从
- 一主多从
- 树状主从

**一主一从**

- 从节点用于主节点的故障转移
- 主节点不要开持久化，以提高性能
- 从节点上开启 AOF 保证数据安全
- 注意：主节点自动重启会丢失所有数据，如果这时候从服务依旧保持复制状态也会清空数据，所以需要先故障转移（或从节点 slaveof no one）后再重启主节点

**一主多从**

又称 星形拓扑结构。

- 多个从节点去处理耗时的读命令，可防止慢查询对业务的影响
- 主从同步信息可能会造成网络阻塞

**树状主从**

又称 树状拓扑结构。

- 从节点不但可以复制主节点数据
- 同时作为下层的主节点向下传递复制数据
- 有效降低主节点负载和 主从复制 的网络成本

## 建立复制过程

由 slaveof 命令触发

1. 从节点保存主节点信息
2. 建立 socket 连接（失败会无线重连）
3. 发送 ping 命令（检测连通性）
4. 权限验证
5. 同步数据集（psync 部分+全量）
6. 命令持续复制

## 数据同步

> 旧版本通过 SYNC 实现，只有全量复制，2.8 版本后实现了 PSYNC 但也兼容 SYNC。

Psync 同步过程分为全量同步和部分同步。

### 全量复制

- 从服务器向主服务器发送 `PSYNC ? -1` 命令，请求完整同步
- 主服务器返回 `+FULLRESYNC <runid> <offset>`，执行 BGSAVE 并用一个缓冲区记录当前的写命令 
- 主服务器将 RDB 文件发送给从服务器，从服务器载入 RDB
- 主服务器将缓冲区的所有命令发送给从服务器，从服务器执行
- 同步完成

### 命令传播

为保持主从的一致性状态，主服务器每次执行的写命令都会向从服务器传播。（主从复制中主从互为客户端）

在传播阶段，从服务器还会以每秒一次的频率向主服务器发送命令 `REPLICONF ACK <offset>` 向主服务器汇报自己的复制偏移量。

- 检测连接
- 检测命令丢失和重传
- 辅助实现主服务器的 min-slaves

> min-slaves 是实现了至少多少个从服务器在指定时间写完才能继续提供写服务，否则会拒绝写命令。

### 部分复制

此功能需要三部分构成：

- 复制偏移量：记录当前数据的偏移量
- 复制积压缓冲区：固定长度默认 1MB 的队列
- 服务器运行 ID：因为 IP+PORT 的形式不可靠，每次重启 runid 会变化，用 debug reload 重启不变

流程：

- 从服务器向主服务器发送 `PSYNC <runid> <offset>` 请求部分同步
- 主服务器（会先检测 runid 和 偏移量）返回 `+CONTINUE` 并发送 offset 后的数据

## 运维事项

- 主从复制下注意永远只在主节点下进行写操作
- 若无法容忍大量延迟，可以编写监控主从偏移量做报警或避免读从
- （3.2版本之前）从节点自身永远不主动删除超时数据，只接受来自主节点的 del 命令才删除
- 惰性删除模式下，主节点只有接收到访问后才会进行检查过期删除
- 关注下主从配置一致的问题，尤其是内存相关的配置（如当数据量超过 maxmember 后会执行内存溢出控制）
- 规避全量复制（耗时、耗资源）
- 规避复制风暴，控制同一主节点下从节点数量

> 避免全量复制 中说了两条
> - 尽量把主节点分散在多台机器上
> - 当主节点故障后用故障转移机制，从而避免恢复后进行密集的全量复制
>
> 看来用故障转移机制是可以避免全量复制的，但 runid 会变化啊，这点我还没找到资料解释这部分内容。