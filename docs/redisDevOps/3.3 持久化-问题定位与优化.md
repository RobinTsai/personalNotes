# 持久化-问题定位与优化

## fork 耗时

fork 是个重量级命令。在执行时虽然不用复制父进程的**物理内存页**，但会复制父进程的空间**内存页表**。

对于高 OPS 的实例来说，fork 操作的影响会很明显。可以通过 `info stats` 查看 `latest_fork_usec` 获取最近一次耗时（微秒）。

改善 fork 耗时：
- 选用高效 fork 的虚拟化技术，如避免使用 Xen 虚拟机
- 控制实例最大可用内存（因为 fork 耗时和内存使用量成正比，线上建议 10GB 内）
- 合理配置内存分配策略，避免物理内存不够
- 降低 fork 执行频率，如放宽 AOF 自动触发时机，避免全量复制

## 子进程开销监控和优化

开销主要在 CPU、内存、硬盘 三部分

开销：

- CPU，Redis 是 CPU 密集型服务
- 内存，消耗主要在复制页表，以及 AOF 重写缓冲区
- 硬盘，主要在持久化时

优化：
- （CPU）不要做单核绑定，利用多核
- （CPU）不要和其他 CPU 密集型部署在同机
- （内存）避免与耗内存的服务同机部署
- （内存）避免在大量写入的时候进行重写
- （硬盘）不要和高硬盘负载的服务同机部署
- （硬盘）AOF重写期间不做 fsync：开启配置 `no-appendfsync-on-rewrite`
- （硬盘）多实例做分盘存储

> AOF 追加阻塞
> 当使用 everysec 的同步策略时，Redis 使用另一个线程每秒执行 fsync 同步到硬盘，当硬盘 busy 时，fsync 缓慢可能会导致主线程阻塞。这种情况下会有日志提示，且解决办法在硬盘上。