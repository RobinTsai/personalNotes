# 位运算的技巧

## Go 中的位运算符

- `&`、`|`、`^` 按位与、或、非
- `^` 二元操作时为异或
- `&^` 清零操作，为二元操作，`a&^b` 等同于 `a&(^b)`
- `<<`、`>>`  左、右移位操作（Go 中的移位是带符号的）

注意，go 中是没有 `>>>` 操作的，这个操作在 java 中为带符号移位操作。

## 移位操作的特点

- 速度快
- 安全，防溢出

安全的特点：比如在算 `a = b * 2` 时，若 b 很大，可能导致溢出报错，但用 `a = b << 1` 的方式的话，则不会报错。

## 取反操作的妙用

### 获得类型中的最大最小值

```go
	// 求无符号数的最大值（用对应类型的 0 取反）
	max_uint64 := ^uint64(0) // 18446744073709551615

	// 有符号数负数是补码表示，所以 ^0 皆为 -1
	f := ^int(0) // -1，int8, int16, int32, int64 皆一样

	// 有符号数的最大值可以这样取（移位是带符号的）
	max_int64 := int64(^uint64(0) >> 1) // 9223372036854775807

	// 有符号数的最小值可以这样算（利用溢出）
	min_int64 := max_int64 + 1 // -9223372036854775808

	// 但注意，常量 +1 会有编译器越界检查，会报错。常量表达式的移位操作将在编译阶段计算值
	// wrong_example := int(^uint(0)>>1) + 1  // 常量 + 1 造成越界编译器不通过
	// 报错：constant 9223372036854775808 overflows int

	// 最小值也可以这样算，但注意这也是在常数上的操作，右移位数超出范围了也会报上方错误
	min_int_2 := int(-1) << 63 // -9223372036854775808

	// 直接得到最小值的二进制（补码形式）
	// 这个二进制表示是 `10000000...`
	a := ^(^uint(0) >> 1) // -9223372036854775808
```

### <span id=3>只保留二进制形式的最右侧一个 1 的十进制数</span>

- 比如，一个数的二进制数 a 为 `11011000`，即要得出 `00001000` 这个数。
- 直接看如下算法：

```go
11011000 // a
00100111 // ^a
00101000 // ^a+1
00001000 // a & (^a+1)
```

此时可以明显得看到 `a&(^a+1)` 就是我们所要的结果。

## 异或的妙用

首先来说说异或运算的性质：

- `0^N == N`
- `N^N == 0`
- 异或满足交换律、结合律

由以上三个性质，我们来介绍下异或的几个算法题：

- 找到一组数据中唯一出现奇数次的数
- 不用额外的变量实现两数交换
- 找到一组数据中有且仅有的两个出现奇数次的数

### 找到一组数据中唯一出现奇数次的数

由上述三条性质，可以有这样的推导公式：

```
a^b^c^b^a == (a^a)^(b^b)^c == 0^0^c == c
```

显然，在一组数据中有且仅有一个奇数次数据时，可以用它进行运算找出。

### 不用额外的变量实现两数交换

另外，异或上述的三条性质可以实现 **不需要额外的变量即可实现两数交换**，以下是证明过程：

```go
	a, b := 'A', 'B'  // 65 66
	a = a ^ b         // a => A ^ B
	b = a ^ b         // b => A^B^B == A
	a = b ^ a         // a => (A^B^B)^(A^B) == B
	fmt.Println(a, b) // 66 65
```

### 找到一组数据中有且仅有的两个出现奇数次的数

- 上面可以完成找出一组数据中有且仅有一个奇数次的数，但如何找出两个呢？
- 假设这两个奇数次数分别为 A、B，因为偶数次所有数异或结果为 0，所以全部结果异或后得到 `A^B`
- 我们从 bit 的维度考虑异或运算，`A^B` 中为 1 的这些位表明仅在 A 和 B 在此位上不同（`0^1^(偶数次 0或1)=1`）
- 因此我们可以按 `A^B` 中任意一个为 1 的位对所有数据进行分组，此位为 0 的一组，为 1 的另一组
- 由于偶数次的数也总是在此位上是偶数次的 0 或 1
- 那么所有为 1 的数异或、所有为 0 的数异或，分别得到 A 和 B 两数
- 单独找某个位为 1 的一个值可以是 `(A^B) & (A^B + 1)`（就是上方 [只保留二进制形式的最右侧一个 1 的十进制数](#3)）

所以此答案是这样的：

```go
// 找出一组数据中有且仅有两个出现奇数次的数
func getTwoOddValue(arr []uint64) (uint64, uint64) {
	// 1 得到全部异或的结果
	xor := uint64(0)
	for _, e := range arr {
		xor ^= e
	}
	// 2 按 xor 的某一个 bit 位的值为 1 的位找出此元素
	// 2.1 找出此 bit 位为 1 的一个值
	singleBitVal := xor & (^xor + 1)
	// 2.2 找出此 bit 位为 1 的那个奇数次元素
	elem_1 := uint64(0)
	for _, e := range arr {
		if singleBitVal&e > 0 {
			elem_1 ^= e
		}
	}
	// 3 找出另一个元素
	elem_2 := elem_1 ^ xor
	return elem_1, elem_2
}
```

---

总结，这里介绍了位操作的一些用法。位操作是性能相当快的操作，而且它还有一些其他的妙用，这些在算法题中常常遇到。本文还介绍了几个简单的算法题：

- 找类型（无/有符号）的最大/小值
- 只保留二进制形式的最右侧一个 1 的十进制数
- 不用额外的空间实现两数交换
- 找出一组数据中唯一出现奇数次的一个数
- 找出一组数据中有且仅有两个出现奇数次的两个数

### 找到唯一一个重复次数不同于其他重复次数的数

- 问题：一组数，其中大多数重复次数都是 a 次，只有其中一个数重复次数为 b 次，且 a 与 b 互质。
- 这个问题也用二进制思路解题：
  - 所有对应 bit 位的和对 a 取余，就能得出特殊数的特殊位
