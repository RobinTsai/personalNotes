## 排序算法

![排序算法.png](/assets/algorithm_sort.png)

- 排序算法的稳定性：就是相同值的两个元素会不会改变它们的次序，不改变就是稳定，改变了就是不稳定。
- [菜鸟教程-排序方法列表一览](https://www.runoob.com/w3cnote_genre/algorithm)

## 选择排序

- [菜鸟教程-选择排序](http://www.runoob.com/w3cnote/selection-sort.html)
- 基本思想：从首个开始为当前节点做如下循环，遍历全部后找到第一小的值，放在当前节点
- 要旨：选择余后中第一小的

## 冒泡排序

- [菜鸟教程-冒泡排序](https://www.runoob.com/w3cnote/bubble-sort.html)
- 基本思想：大值一直靠后移动。相邻两数比较，交换，大的放后面，后半拉是排好的。
- 和选择排序的不同在于：相邻的进行比较、交换……
- 和插入排序思路基本一致，只是插入排序是选择一个值向前移动。

## 插入排序

- [菜鸟教程-插入排序](https://www.runoob.com/w3cnote/insertion-sort.html)
- 简单排序中最好用的一种。
- 基本思想：（冒泡的反向）顺序选择，向前比较进行交换，小的前置。前半拉是排好的。

### 前三种排序小结

- 前三种很类似，只是思考角度不同。平均复杂度也是一致的。
- 选择排序是总是选择余后部分的最小值
- 冒泡排序是大值一直两两交换后移
- 插入排序是小值一直两两交换前移

## 希尔排序

- [菜鸟教程-希尔排序](https://www.runoob.com/w3cnote/shell-sort.html)
- 改进的插入排序。
- 基本思想：以固定间隔对应的值先排序（插排）；缩小间隔直到间隔为 1。
- 优点主要在：间隔大时移动的个数少；间隔小时移动的距离短。

## 归并排序

- [菜鸟教程-归并排序](https://www.runoob.com/w3cnote/merge-sort.html)
- 基本思想：（分块递归）`f(n)` 为数组分两半，分别对两半进行排序（同样用 `f(n)`），最后将两半整合（二路归并）。
- 时间复杂度： N 个数大概分 logN 次，每个小组排序时间大概为 N，所以是 `O(NlogN)`
- 空间复杂度：因为使用了就释放了，所以仅 `O(N)`
- 一般语言的对象排序都是归并排序（如 java、python）。对象排序一般要求稳定。

## 快速排序

- [菜鸟教程-快速排序](https://www.runoob.com/w3cnote/quick-sort-2.html)
- 快排中经典的叫“单轴快排”，改进的叫“双轴快排”。轴（pivot）。
- 基本思想：以轴为中心，将比轴小的排前面，大的放后面；（递归）将轴外两部分再次按轴进行分……直到轴两边的元素少于 1 个。
- 每次找中轴越接近中点，越高效
- 实现方式有优有劣，关键在于找中轴的两侧块的方法（哪个是轴可以任意选）：
    - 1. 从一侧出发，小于轴的掠过，大于轴的放后面，最后将轴放在合适的位置（和最后一个小于等于轴的进行交换）。
    - 2. 从两侧出发（略过轴），前侧找小于轴的，后侧找大于轴的，两者都找到不符合的，交换一下，继续找，最后将轴放在合适的位置。
- 时间复杂度：每分一次需要遍历 N 次，分的次数为 logN 次（每次分两半嘛），所以时间复杂度为 `N*logN`。
- 空间复杂度：因为每分的一部分都需要临时变量，所以为 `logN`
- 双轴快排：两个轴，分为三部分。

### 小结：排序方法的选择技巧

工业上的数组排序（Array.sort() 内部实现，提前预判）

- 一小块一小块排得比较好，用归并
- 数组短，插入
- 然后考虑快排
    - 取 5 个数，相等，单轴
    - 不相等，双轴

## 堆排序

- [菜鸟教程-堆排序](https://www.runoob.com/w3cnote/heap-sort.html)
- 思想：首先需要建大根堆，根节点最大，每次取根节点后维护剩余堆为大根堆
- 大根堆：完全二叉树内节点的关系保持为——父节点总是大于两个子节点
- 特性：大根堆本身是不保证全部元素顺序（升序或降序）的，但知道最大者
- 在排序算法中，大根堆用于从小向大的排序（因为堆顶总是和最后一个元素进行交换，不需要额外空间）
- 步骤分两步：首先需要建立大根堆，然后大根换到最后节点排除在堆外，并维护大根堆
- 建立大根堆：
  - 1. 数组本身是一种存放堆的数据结构
  - 2. 从叶子节点开始每一层与父节点进行比较，大值上移，直到最后根节点（完成大根堆的构建）
- 排序：
  - 1. 最大值（根节点）和根的最后一位进行交换
  - 2. 缩小堆的范围，不考虑最后一个节点
  - 3. 交换后的堆顶进行下移，维护大根堆特性
  - 4. 重复以上步骤直到循环到根节点

完全二叉树：

- 定义：二叉树中，除最底层外的每层是满的，最底层从左到右是依次变满的（中间没有空隙）
- 多数 0 号元素弃而不用，这样可以维持以下关系
  - 本节点下标为 i 时
  - 父节点为 `i/2` （`i >> 1`）
  - 左子节点 `2i` （`i << 1`）
  - 右子节点 `2i + 1` （`i << 1 | 1`）

## 计数排序

- [菜鸟教程-计数排序](https://www.runoob.com/w3cnote/counting-sort.html)
- 非比较排序；桶思想的一种。桶排序都是非比较的排序。
- 适用范围：数组元素的个数比较大，但值都比较小。如员工年龄。
- 基本思想：数组的下标做为要排序的值，数组元素值作为个数。
- 空间复杂度： N+K，N 是排序结果数组，K 为桶的个数。
- 时间复杂度：N+K，N 为元素加加的次数，就是元素的个数；K 为返回结果时对桶的遍历。
- 计数排序变成稳定的：需要再遍历原数组，按序生成目标数组。

## 基数排序

- [菜鸟教程-基数排序](https://www.runoob.com/w3cnote/radix-sort.html)
- 非比较排序；桶排序的一种。基数排序本质是一种多关键字的排序。

基本思想：
- 先按个位数字入桶，按顺序取出（桶按由小到大排序）；
- 再按高一位的继续重复上一步，不足的位数按此位为 0 计，直到取到最高位……
- 放入和取出都要从小到大，这个桶不能是 map，应该是个 FIFO 的数据结构
- 由于放入和取出是有顺序的，所以在最后取出后结果是由小到大排好序的
- 空间复杂度： 可以做到 O(N)。（用数组时需要每个桶长度都是 N，即 10N；用链表时可以做到 N）
- 时间复杂度： 就是一次一次复制。O(N*K)，N 为数据量的个数，K 为建一系列桶的次数，也就是数据的位数。

总结：

- 本质是一种多关键字的排序
- 有低位优先和高位优先两种
    - LSD（Least Significant Digit first）低位优先，如上。
    - MSD（Least Significant Digit first） 高位优先。递归的思想（容器的思想）。

## 桶排序

- [菜鸟教程-桶排序](https://www.runoob.com/w3cnote/bucket-sort.html)
- 基本思想：通过按范围分桶，桶内再单独排序。最后按顺序输出。
- 和基数排序不同的是，这里按大小区间分桶，而基数排序是按位值分桶（个位、十位……）

普通的桶算法排序不常用，只有特殊场景才有用。原因：

- 桶内还需要排序
- 不好分桶
- 桶不好用数据结构存
    - 若用 ArrayList（go 里是 slice）会有数据空间增长的问题。
    - 若用链表，链表的排序特别麻烦，相当于冒泡思想。

它的时间复杂度和空间复杂度也相当麻烦。
