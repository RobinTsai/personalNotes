# 树

- 二叉树：最常见是二叉树
- 二叉树的递归性质：二叉树是典型具有递归性质的数据结构
  - 递归中，相当于每个节点都有机会被考虑为父节点做分析
  - 递归都能改为迭代
  - 递归改成迭代需要用到栈结构
  - 递归改成迭代需要用两层 while 循环，外层循环比内层多一个栈是否为空的条件
- 递归的栈溢出：递归中，如果栈深度过大可能会导致栈溢出（函数栈帧）
  - 使用栈结构：使用栈结构也可能会发生栈溢出，具体要看内存分配空间的大小
  - 使用尾递归：是一种优化，递归调用是函数的最后一个操作，编译器会将其转换为循环
- DFS 深度优先遍历：常用前序、中序、后序——参考操作父节点的时机而定义的
  - 前序：父 - 左 - 右
  - 中序：左 - 父 - 右
  - 后序：左 - 右 - 父
  - 另外其他遍历方式也能做到：右 - 左 - 父
- 广度优先遍历：就是按层遍历
- **二叉搜索树**：
  - 性质：中序遍历是顺序的（可以用来判定是否二叉搜索树）
  - 性质：父节点大于等于左子树各节点，小于等于右子树各节点（可用递归判断是否二叉搜索树）
  - 常用的算法是：中序遍历
- **平衡二叉树**
- 复杂度（常规问题的复杂度）：
  - 普通二叉树：最优的时间复杂度是 O(n)（每个节点都要考虑到）
  - 二叉搜索树：最优的时间复杂度是 O(h)（h 是树的高度，用到了排序的性质）

## 二叉树的遍历（递归和迭代）

- dfs 就是要灵活应用遍历
- 性质：dfs 时，每个节点都有机会被考虑为根节点

### 例题一：前序、中序、后序

```go
// 递归，前序、中序、后序

func dfs(root *Node) {
  if root == nil { return }
  // options1: print(root.val) 放这里就是前序
  dfs(root.left)
  // options2: print(root.val) 放这里就是中序
  dfs(root.right)
  // options3: print(root.val) 放这里就是后序
}
```

### 例题二：递归改为迭代

```go
func traverse(root *Node) {
  stack := make([]*Node, 0)
  cur := root
  for cur != nil && len(stack) > 0 {
    for cur != nil {
      // options1: print(cur.Val) 这里处理是前序（入栈之前）
      stack = append(stack, cur)
      cur = cur.Left
    }

    cur = stack[len(stack) - 1]     // 1
    stack = stack[:len(stack) - 1]  // 2
    // options2: print(cur.Val) 这里处理是中序（出栈之后）
    cur = cur.Right                 // 3
    // 后序的迭代这里要复杂，因为要判断其右子树是否已经判定过，判定过之后才能在这里操作
  }
}

// 后序的迭代需要将 上述 1、2、3 处更改为
func traverse(root *Node) {
  // 最前定义一个 prev
  // ...
  cur = stack[len(stack) - 1]
  if cur.Right != nil && cur.Right != prev {
    cur = cur.Right
  } else {
    stack = stack[:len(stack) - 1]
    print(cur.Val)  // 在这里处理为后序
    prev = cur
    cur = null
  }
}
```

### 其他例题

- 题一：从根节点到叶子节点的路径数字之和（普通遍历）
- 题二：从某节点到叶子节点的路径数字之和等于某值的个数
  - 特点：某节点，不一定是根节点了
  - 提示：因为 dfs 会将每个节点都有机会考虑为根节点，所以用 dfs 递归收集即可
- 题三：从某一节点寻路到任意另一个节点间数值和的最大值
  - 递归记录每个节点为根时的子树的最大值

## 二叉搜索树

- 性质：顺序性
- 性质：`根 >= 左子所有节点`；`根 <= 右子所有节点`
- 特点：一般出的算法题时间复杂度降到 O(h)

## 二叉搜索树的迭代器

- 迭代器，是指构造一个对象，有方法 `next()` 总是取当前节点的顺序下一个节点。
- 有了这个迭代器，我们可以按调用次顺序取到下一个节点。
- 再构造一个反向的（降序的）迭代器，就能逆序使用。

## 平衡二叉搜索树：TreeSet 和 TreeMap 的应用

> 不好说，需要直接因为库中的结构
> 说了一个例题很典型，列出来，但最优解用的是桶的思想

- 例题：一个给定整数数组，和两个正整数 k、t；问：是否存在两个下标 i、j 使得 i、j 距离小于 k 且 两者的差值绝对值不大于 t。
  - 用桶的思想：将数值放入若干个大小为 t+1 的桶，则转换成在同桶以及相邻桶中找满足的 i 和 j
