# 链表

## 哨兵节点

- 描述：哨兵节点通常在链表头部，是为了简化处理链表边界条件而加，首节点肯定不为 null
- 作用：哨兵节点可简化 插入、删除 操作

## 双指针法

- 前后双指针：一定跨度，速度相同
- 快慢双指针：速度不同

### 常见题一：删除倒数第 k 个元素

- 前指针先走 k 步，然后两个指针同时走。
- 前指针走到最后一个元素时，后指针走到 *倒数 k+1* 节点，将 *倒数 k+1* 节点指向 *倒数 k-1* 节点即可
- 注意：如果前指针走出链表（== null），则后指针走到 *倒数第 k* 个节点

### 常见题二：找环入口节点

- 步骤一：快慢指针找到任意一个环内节点（判断有环：重合则有环，不重合则无环）
- 步骤二：在环内任意节点循环一圈回到此节点找到环节点个数 m
- 步骤三：前后指针，前指针先走 m 步，然后同时走，直到重合的点即为入口点

不需要知道环内多少节点的做法：

- 快慢指针，快指针一次走两步，慢指针一次走一步
- 当重合时候快指针比慢指针多走了 k 步
- 因此 k 步一定是环内节点数的整数倍（为什么不是确定的 1、2 倍呢）
- 因此，若保持 k 步的差距从头出发，那么相遇点一定是入口节点

### 常见题三：两个在某节点重合的链表的第一个重合点

- 方法一：使用构环法，将末节点指向另一个节点的 head，则转变成求环的入口点
- 方法二：将两个列表分别入栈，最后同时弹出进行比较，直到最后一个相同点即为第一个重合点（用空间换时间，空间 O(m+n)）
- 方法三（最优）：遍历两个链表，比较长度差 k，则长节点先走 k 步，然后同时出发，相遇的点即为第一个重合点（时间 O(m+n)）

## 反转链表法

```go
function reverseLink(head *Node) *Node {
    prev := null
    cur := head
    for cur != null {
        next := cur.next
        cur.next = prev
        prev = cur
        cur = next
    }
    return prev
}
```

## 双向链表和循环链表
