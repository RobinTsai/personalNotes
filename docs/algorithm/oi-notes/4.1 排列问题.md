# 全排列问题

- n 个数的全排列一个有 n! 种。
- n 个数中任意 m 个数的全排列有 (n!)/(n-m)! 种。
- n 个数中任意 m 个数的组合（无序），共有 Cn|m = n! / (m! * (n-m)!) 种。（Cn|m 是 n 在 C 的右下角，m 在 C 的右上角。）

注意：

- 排列，考虑顺序
- 组合，不考虑顺序

## 递归回溯法

递归法适用于不含重复值的全排列，如果含重复值，则需要进行去重处理或用其他方法。

- [力扣-46. 不重复数的全排列](https://leetcode.cn/problems/permutations/)

如有 n 个数 {1 2 3 ... n}，它的全排列：

- 思路：
    1. 让第一个数不同，得到 n 个数列
    2. 在上述每一个数列中，让第二个数不同，则每个数列又多出 N-1 个数列
    3. 重复以上思路直到最后一个数
- 复杂度 O(n!)，由于要输出所有，所以没有更优化的复杂度。
- 编程思路：
    - 存储考虑：引用传递或闭包
    - 第一个数与后面每一个数进行交换
    - 存储时机：交换者 i 遍历到最后时进行存储

- 细节及误区：
    - **j 从 i 开始**，表示 i 和本身进行一次交换
        > 不可 j 从 i+1 开始，否则丢失每次递归开始的第一个不交换的序列
    - **存储时机**是在 i 遍历完 nums 时（i >= n）进行存储
        > 不可在每交换一次就存储，否则会由于 i 与 i 的交换导致多出 n 个重复项
    - 上述 两个问题 组合起来也是没法弥补的，所以要切记
    - 单纯的递归无法对 **含重复数数列** 做全排列，需要额外加 **去重** 操作或其他方法。

```go
// 力扣-46. 全排列 https://leetcode.cn/problems/permutations/
func permute(nums []int) [][]int {
    res := make([][]int, 0)

    var recursion func(int)
    recursion = func(i int) {
        if i >= len(nums) {
            res = append(res, append([]int{}, nums...)) // 存储
            return
        }
            
        for j := i; j < len(nums); j++ { // i 与 [i+1..n) 交换
            nums[i], nums[j] = nums[j], nums[i]         // 交换
            // res = append(res, append([]int{}, nums...)) // 存储误区
            recursion(i + 1)                            // 递归
            nums[i], nums[j] = nums[j], nums[i]         // 恢复
        }
    }

    recursion(0)
    return res
}
``` 

将上节代码修改一处就可以求任意 m 个数的全排列。即存储的位置：

```go
res = append(res, append([]int{}, nums[:k]...)) // 存储
```

### 含有重复值的全排列

含有重复数的全排列必须通过去重操作来做，而单纯的用递归+回溯是无法做到的。（不排除个人见识问题）

你可能会想上述中用 `if (i != j && nums[i] == num[j]) {continue}`。但实际也是不可以的，这是因为关键不是要考虑重复值的交换问题，而是考虑交换后的重复问题。

如：{2 2 1 1} 即可以通过 {2 1 1 2} 在下标 1 和 3 交换后得到，也可以通过 {2 1 2 1} 在下标 1 和 2 交换后得到。
