# 架构

## 逻辑架构

```
Client --> 连接/线程处理 -> 解析器 ---> 优化器 ---> 存储引擎
        │      │           ↓                  │
        │      └──────> 查询缓存               │
------- │ ----------------------------------- │ -----------
 第一层 │               第二层                 │    第三层
```

- 第一层：连接处理、授权认证、安全
- 第二层：查询解析、分析、优化、缓存及所有内置函数，以及跨存储引擎的功能实现：存储过程、触发器、视图
- 第三层：存储引擎，负责 MySQL 数据的存储和提取

## 并发控制：锁

- 读写锁，读锁又叫共享锁；写锁又叫排他锁
- 锁粒度，更精确的锁能提高共享资源的并发性；频繁的加锁会对系统性能造成一定影响（加锁、检查锁、管理锁等）
- 锁策略，在锁的开销和数据的安全性质检寻求平衡，MySQL 的各种引擎提供了多种选择可以控制锁策略和solidus
  - 表锁：粗粒度，开销小。写锁优先级更高，可能插到读锁前面
  - 行级锁：细粒度，开销大。行锁只在存储引擎层面实现。

## 事务

- 开始一个事务：`START TRANSACTION;`
- 提交一个事务：`COMMIT;`
- 撤回一个事务：`ROLLBACK;`

### ACID

ACID：良好的事务具备 ACID 标准特征

- 原子性（Atomicity）：一个事务是可不分割的最小工作单元
- 一致性（Consistency）：没有提交的修改，不会保存到数据库
- 隔离性（Isolation）：一个事务在最终提交前的修改，对其他事务不可见
- 持久性（Durability）：一旦事务提交，修改就会永久保存到数据库

### 事务的隔离级别

事务的隔离级别：SQL 标准定义了四种隔离级别，每种级别定义了事务中的修改的可见性。较低级别有更高的并发性和更低的开销。

由低到高依次是：

- READ UNCOMMITTED（未提交读）：即使没有提交，对其他事务可见
  - 脏读：某事务读到了另一个事务未提交的变更。
  - 另外有 不可重复读、幻读 的问题。
- READ COMMITED（提交读）：提交之后对其他事务可见
  - 不可重复读：在一个事务内的多次读，会因另一个事务提交前、后不一致。
  - 另外还有 幻读 的问题。
- REPEATABLE READ（可重复读）：保证在同一个事务中多次读取数据的结果一致
  - 幻读/幻行：在事务读取范围时，另一个事务在范围内插入了新记录，导致本事务两次读取不一致。
- SERIALIZATION（可串行化）：对读取的每行都加锁，可能产生大量的超时和锁争用问题。

可重复读是 MySQL 的默认事务隔离级别。InnoDB 和 XtraDB 使用 MVCC 解决了幻读问题。

> 另外还有一个隔离级别叫脏写：一个事务修改了另一个事务修改（不一定提交）的数据。这是不允许的。

### 死锁

- 原因：不通顺序的两个或多个锁互相卡；在部分存储引擎中同顺序的锁也可能产生死锁。
- 自检：系统自己检查死锁是否发生，有多种检测和超时机制，返回错误
- 恢复：将最少行级排他锁的事务回滚

死锁是无法避免的，应用程序中应该要对事务死锁导致的失败做处理，如重新执行。

### 事务日志

> 事务日志提高了事务的执行效率，避免了随机 IO 直接写库。

事务日志：事务中在变更数据时，变更内存中的数据，然后采用追加的方式将变更行为记录到事务日志中（顺序IO）。内存中的修改会在合适的时机刷回磁盘。

这叫 Write-Ahead Logging，预写式日志。修改数据会有两次写磁盘操作。

事务的提交会保证写到事务日志中。若此时发生系统崩溃，存储引擎在重启时会自动恢复这部分修改的数据。

### MySQL 中的事务

MySQL 中提供了两种事务型存储引擎：InnoDB 和 NDB Cluster，另外的就是部分第三方存储引擎，如 XtraDB、PBXT。

- 自动提交（默认模式）：每一个操作都被当做一个事务执行提交操作。关闭自动提交后必须显式地用 COMMIT 提交或 ROOLBACK 回滚（相当于所有操作在一个事务中）。
- 隐式提交：有一些命令在执行前会强制 COMMIT 提交活动的事务。如 DDL、Altar Table 等
- 隔离级别设置：可以通过 `SET [SCOPE] TRANSACTION ISOLATION LEVEL [XXX]` 来设置隔离级别，在下一个事务生效。InnoDB 支持上述四种隔离级别。

```sh
SHOW VARIABLES LIKE 'AUTOCOMMIT'; # 查看自动提交开关
SET AUTOCOMMIT = 1;  # 打开自动提交开关
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED; # 设置 session 级的 隔离级别 为 提交读
```

### 事务中混合使用存储引擎

事务由下层存储引擎实现，在同一个事务中使用不同的存储引擎时不可靠的。

如同时使用了事务型和非事务型存储引擎，当需要回滚时非事务型表上的变更无法撤销（会发出警告），导致最终结果不一致。

### 锁的显式和隐式锁定

- 隐式锁定：在事务中随时都可能发生锁，直到事务终止才会释放，InnoDB 会根据隔离级别在需要的时候自动加锁。
- 显示锁定：`SELECT ... LOCK IN SHARE MODE` 或 `SELECT ... FOR UPDATE`

> 隐式锁定中用的是 **两阶段锁定协议**，分为 *扩展阶段* 和 *收缩阶段*；
> 扩展阶段：此阶段下，事务可以 **获得** 任何数据项上任何类型的锁，但不能 **释放**。
> 收缩阶段：此阶段下，事务可以 **释放** 任何数据项上任何类型的锁，但不能 **获得** 新锁。
> 两阶段锁在一定程度上保证了事务的可串行化。

## MVCC

多版本并发控制。多数 DB 都实现了 MVCC，机制不尽相同，因为没有统一标准，原理是写操作只锁必要的行，读操作非阻塞。

MVCC 使用版本来控制竞争，避免了加锁操作，开销更低。

MVCC 的实现，是通过保存数据在某个时间点的快照来实现的。具体来说是每个行记录后面保存两个隐藏的列，分别记录行的创建版本和过期版本。每个事务有唯一的版本号，系统下所有事务的版本号是递增的。

MVCC 只在 REPEATABLE READ 和 READ COMMITTED 两个隔离级别下工作，实现差别在于 **生成一致性视图的时机不同**。另外两种，READ UNCOMMITTED 总是读取最新的行，SERIALIZABLE 对所有读取的行加锁，都用不上。

## MySQL 中的存储引擎

MySQL 的每个数据库对应文件系统上的一个目录。每个表的定义存储在目录下同表名的 .frm 文件。

```SQL
SHOW TABLE STATUS LIKE 'user'\G -- 查看表的信息（引擎、大小、字符集等）
```

### InnoDB

是 MySQL 中默认事务型引擎。除非有非常特别的原因用其他引擎，都应该用 InnoDB。

特性：

- 每个表的数据和索引存放在单独的文件中。
- MVCC：采用 MVCC 来支持高并发，实现了四个隔离级别，默认级别为可重复读，并且通过 **间隙锁** 来防止幻读（幻行）。
- 聚簇索引：InnoDB 基于聚簇索引建立，有很高的查询性能。不过注意二级索引上都包含主键列，主键过大的话每个索引都会很大（主键应尽可能小）。
- 内部优化：InnoDB 内部做了很多优化，如从磁盘读数据时采用 **可预测性预读**，能自动在内存中创建 **哈希索引** 加快读操作
- 热备份支持：InnoDB 通过一些机制和工具支持真正的热备份

### MyISAM

> MySQL 5.1 及之前的版本，MyISAM 是默认的存储引擎。

- 提供了大量特性：全文索引、压缩、空间函数
- 但不支持：事务、行级别锁
- 且：崩溃后无法安全恢复

特性：

- 存储两个文件：数据文件（.MYD）和索引文件（.MYI），存储行记录数受限于系统的最大文件尺寸。
- 只负责写道内存，操作系统定期刷盘（崩溃后数据丢失）
- 加锁和并发：只支持表加锁，不支持行锁
- 修复：可以手工或自动检查和修复数据，但修复操作慢，且会导致部分数据丢失（不支持事务）
- 索引特性：可以基于前 500 个字符创建索引；支持全文索引
- 延迟更新索引键：有开关控制，修改的索引数据先写到内存，待合适时机刷盘（但崩溃后修复会丢数据）
- 压缩表：如果表在导入后不会有更新（包含插入）操作，可以用压缩表。好处：节省磁盘，节省 IO，提升查询性能，同样支持索引。
- 设计简单，数据以紧密格式存储。

### 其他存储引擎

- Archive 引擎：只支持 INSERT 和 SELECT 操作。
- Blackhole 引擎：丢弃所有插入数据（Black hole），但会记录日志。可用于复制数据到备库或只是记录日志。
- CSV 引擎：MySQL 直接读取 CSV 文件。不支持索引。
- Federated 引擎：访问其他 MySQL 服务器的代理，会创建一个到远程 MySQL 的连接并查询。
- Memory 引擎：保存在内存中，查询速度快一个级别，重启后数据丢失（但表结果保留），表级锁并发写的性能低。内部用的临时表就是 Memory 表。
- Merge 引擎：多个 MyISAM 表合并的虚拟表。
- NDB 集群引擎：集群。
- 第三方存储引擎

## 引擎的选择

- 优先使用 InnoDB 或 InnoDB + 其他组合（如用到全文索引，优先考虑 InnoDB + Sphinx）
- 除非万不得已，不要混合多种存储引擎
- 考虑以下因素：
  - 事务：InnoDB、XtraDB 支持；不用事务只用 INSERT 和 SELECT 时 MyISAM 合适（日志型）
  - 备份：仅 InnoDB 支持热备份
  - 崩溃恢复：InnoDB
  - 特有特性：MyISAM 支持地理空间搜索

### 日志型应用

- 插入速度要求高 -> 用 MyISAM 或 Archive
- 要用日志做分析报表（生成报表可能严重影响插入效率）-> 使用复制方案到备库，在备库上做耗 CPU 的查询 -> 用日期分表，第二条生成报表


## 表引擎的转换

有多种方法，各有优劣

- ALTER TABLE：执行时间长，原理是按行复制，消耗 IO 及在原表上加读锁（会被写阻塞）。InnoDB -> MyISAM -> InnoDB 后原来的外键丢失。
- mysqldump 导出后导入：导入前会自动 drop 同名表，所以导入到另一个表名后再改名是个很好的方式
- INSERT...SELECT：更安全。建议用事务分批处理，事务太大会产生过多 undo。执行过程中为避免结果不一致可以给原表加锁。
