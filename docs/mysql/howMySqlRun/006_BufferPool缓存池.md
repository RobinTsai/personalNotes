# Buffer Pool 缓存池

用于磁盘与 CPU 之间缓存，通过将磁盘中的 **页数据** 加入到 **连续的内存** 中缓存起来，进而降低 IO 开销。

通过配置可配置缓存池大小，默认 128M，最小 5M，配置小于 5M 也会是 5M。

`SHOW ENGINE INNODB STATUS` 中可以查看 Buffer Pool 的状态信息。

```yaml
# 配置项
[server]
innodb_buffer_pool_size=268435456 # 总空间
innodb_buffer_pool_instatnces=2
innodb_buffer_pool_chunk_size=134217728 # 默认 chunk size 128M
```

![buffer pool](/assets/mysql_buffer_pool.png)

## 内部组成

> - Buffer Pool 可以有多个实例
> - 每个实例中又分有多个 chunk
> - 每个 chunk 是由控制块和缓存页组成
> - 控制块是每个缓存的页对应一个控制信息存储在内存中，控制块大小固定。

- 缓存页，从 磁盘 上 load 进来的页
- 控制块，和缓存页一一对应，记录了表空间、页号、缓冲页地址、链表节点信息等

由缓存页和控制块构成。控制块是连续的空间，缓存页也为连续的空间。每个控制块中有指针唯一的指向一个缓存页（一一对应，但顺序不一定对应）。

- 缓冲页改变了但还没刷盘，就是脏页
- Buffer Pool 中用不到的空间，就是碎片

```
+-------++-------+-----+-------++-------++-------+-----+--------+
| 控制块 | 控制块 | ... | 控制块 ║  缓存页 | 缓存页 | ... | 缓存页 |
+-------++-------+-----+-------++-------++-------+-----+--------+
    └─────────┐       ┌───┘
链表基节点： start ,  end , count
```

控制块会组成多个链表：

- free 链表（空闲页链表），每次 load 新页时从这里取一个空闲页装载。
- flush 链表（脏页链表），每对页数据修改后还没同步到磁盘前的数据页。
- LRU 链表，用于记录页的使用以及释放页以存储新数据页。
- 其他链表，如 unzip LRU 链表、zip clean 链表、zip free 链表

链表基节点（存放指向头节点、尾节点、节点长度等信息）不存放在 Buffer Pool 中，而在单独申请的内存空间。

## 如何寻找缓存页

寻找缓冲页：通过 **表空间号 + 页号** 作为 key，缓冲页的 **控制块地址** 作为 value 会构建出一个 **哈希表**。

通过这个哈希表能快速找到这个控制块地址，从而找到页所在内存。当查某个表下数据时，B+ 树中存储了数据所在的页号信息。

（哈希表存储在哪里呢？）

## LRU 链表

Buffer Pool 的空间可能会不够，就需要有一种方案从缓冲中淘汰用不到的，load 进来新的频繁使用的。这就是 LRU 链表存在的意义。

简易版的设计：

- 访问页不在缓存池中，将缓存页放到 LRU 链表头位置
- 访问页已经在缓存池中，将缓存页放到 LRU 链头位置（记录最近使用了）
- 当空间不够时从 **尾部淘汰**

为了提升效率，引入了 预读。

### 预读（read ahead）

- 概念：在执行请求时 mysql 会将查询数据后面或相关的页也加载到缓存中。以备所需。用到了就提高了效率。
- 包含线性预读和随机预读（分别用两个系统变量控制开关）。


预读的副作用：

- 预读的数据 **用不到时**，由于会加在 LRU 头部，会迫使 LRU 列表发生尾部淘汰。
- 全表扫描是 **临时用的**（一次性用的），会将常用缓冲页排挤出 Buffer Pool。

对副作用的优化：

- 分区：Young 区和 old 区，分别存储热数据和冷数据。

### LRU 链表划分区域

mysql 的做法时按照某个比例将其分成两部分，young 区在前，old 区在后。

- young 区，热数据，使用频率非常高，在 LRU 前半部
- old 区，冷数据，使用频率不高，在 LRU 后半部
- “冷冻时间”，记录第一次放入 old 区的时间，在一定时间间隔内重复访问不移动，超过这个时间后再访问就移动到 young 区头部

问题的解决：

- 针对于“是否使用的问题”：**初次** 用到的页会先加到 old 区头部，再根据访问放到 young 区头部。
- 针对于 “仅临时使用问题”：如果某 **时间间隔** 外再次使用到 old 区头部缓冲页，则放到 yound 区。

但还有一个问题：已经在 young 区头部的缓冲页在频繁被访问，会一直做“节点移动到头部”这件事，很浪费性能。mysql 优化：

- 访问 LRU 链表 young 区前 1/4 数据时，不进行节点移动，访问后方区域时才移动。

> 据说还有很多优化内容，没有一一讲到。

## flush 链表的刷盘

后台有专用线程，每隔一段时间就把脏页刷新到磁盘中。刷新方式：

- 从 LRU 链表中冷数据中刷新一部分页面到磁盘（被称为 BUF_FLUSH_LRU 方式）
- 从 flush 链表中刷新一部分页面到磁盘（BUF_FLUSH_LIST）

还有一种方式是在 free 链表已经没有空间时，那么不得不

- 从 LRU 尾部取到一个页，为脏页则刷盘（严重低效）（BUF_FLUSH_SINGLE_PAGE）

> flush 的刷盘还有很多考虑，后面待在其他地方补充

## Buffer Pool 的多实例

由于在访问 Buffer Pool 中的各个链表时，都是需要 **加锁** 的，用于防止并发冲突。所以只有一个实例肯定效率不高。

因此，Buffer Pool 在内存中实际是由若干个小实例组成的，各自管理内部的链表。可以通过 `innodb_buffer_pool_instatnces` 来控制个数。

```
每个实例的大小 = innodb_buffer_pool_size / innodb_buffer_pool_instatnces
```

## Buffer Pool Chunk

在 5.7.5 版本之后，允许在 runtime 过程中调整 Buffer Pool 大小，但此操作需要先申请内存然后将旧空间中内容复制到新空间——极其耗时。因此将 Buffer Pool 分块了，申请内存空间时 **以 chunk 为单位** 向操作系统申请的。

即，一个 Buffer Pool 由多个 chunk 组成，每一个 chunk 是一块连续的内存空间，里面包含了若干个 控制块和缓冲页。

配置项 `innodb_buffer_pool_chunk_size` 用以控制每个 chunk 的大小。（他们之间有倍数关系，如果配置不符也会保证倍数关系，这里就不说了，用到了后查询资料吧）
