# B+树索引

在页结构中的排列上我们查不多已经讲了 B+树 的样子了。

## B+树的特性

B+ 树索引也是用 **页** 来构成的：

- 最下层是叶子的页，这些数据页存放的都是普通的用户记录（行记录 record_type=0，聚簇索引）
- 最上面是树根，是百年不动的
- 树根和到叶子节点中间的页，是目录项记录（行记录 record_type=1）
- 目录项记录只是将 **主键**（页中起始主键）和 **页号** 记录为两个列，形成记录。其他构成方式与先前介绍的页相同
- 同层的页是双向列表。可以理解为在叶子节点，向上一层层抽出一个目录页层，直到树根
- 一般叶子节点层为 0 层（最下层）

---

- 聚簇索引：叶子节点存储完整的用户记录就是聚簇索引。InnoDB 中，聚簇索引就是数据的存储方式。“索引即数据，数据即索引”。
- 二级索引：与聚簇索引不一样，叶子节点只存储行的主键。在查询完整信息的时候还需要进行回表操作。
- 另外一点：聚簇索引中目录页不需要存储主键列，仅索引列+页号；而二级索引是需要存储主键列的，索引列+主键列+页号。
  - 这是因为在二级索引中插入数据时，很可能不同页有相同的索引列，这样需要遍历到下一层页（甚至到叶子页）才能知道插入到那个页中，如果加入主键就只需要比较两个页就可以了。
  - 所以某些列的二级索引也是，这些列+主键的索引
- 联合索引：又叫多列索引、复合索引，本质也是个二级索引。
- 页分裂：当一个页在插入数据，但没有空闲空间的时候，为了保持上述 B+ 树的结构就会发生页分裂。

---

MyISAM 中的索引方案:

- MyISAM 中索引也是 B+树，但索引和数据是分开的。
- MyISAM 会把索引信息单独存储到另一个文件中（索引文件）。不存在聚簇索引，在索引叶子节点中存储主键+行号。
- 相当于只有二级索引。

总结一下：

- 每个索引都是一个 B+ 树
- 用户记录和目录项记录：B+ 树分很多层，所有用户记录存储在叶子节点，所有目录项记录存储在内节点
- 聚簇索引：InnoDB 为主键列建立聚簇索引（没有显示的主键列，会次选非 NULL 的 Unique 列，再次用隐藏主键列）
- 二级索引：我们可以自行创建二级索引，二级索引叶子节点的用户记录时 索引列 + 主键
- 回表：二级索引中在查找完整的用户记录需要回表
- 双向链表：B+ 树的每层节点都是按索引列值从小到大排序组成的双向链表
- 单向链表：且每个页内记录都按索引列的值从小到大排序组成单向链表
- 索引的查找：在索引的查找时，是从 B+树一层层向下搜索的，每个页中划分组，每个组中最大索引列为槽，存放在页目录中，这样通过二分法能快速定位某个记录

## B+树索引的使用

索引的代价：

- 首先是空间上的代价：每个索引构成一个完整的树，占用存储空间
- 再者是时间上的代价：每做增删改的时候，都需要考虑各 B+ 树索引的维护，如页分裂、页回收等等；另外索引多了，执行计划分析的过程也会变多，从而影响性能。

索引的使用：

- 扫描区间
- 排序：在内存或磁盘（内存中满足不了会借助磁盘存放中间结果）中进行排序叫文件排序
- 排序：注意 Order By 子句后面的列的顺序也必须按照 索引列 的顺序给出，而且不可以 ASC、DESC 混用
- 分组：正好分组顺序与索引列顺序一致，是可以命中索引的
- 回表的代价：回表大多会产生大量随机 IO，有时候不如用全表扫描。如果回表查询的数据量越大，用全表扫描越合适。用 limit 限制回表个数。

更好的使用索引：

- 只为用于搜索、排序、分组的列创建索引（不要冗余）
- 考虑索引列中不重复值的个数（越少可能回表越多，最好区分度大些）
- 索引列尽量小（因为会占用磁盘空间，查询时候也有 IO 性能消耗）
- 为列前缀创建索引（对于大值列情况，但排序支持不好）
- 覆盖索引，彻底告别回表
- 索引列不要用函数或公式
- 插入数据的主键最好是顺序的，不要忽大忽小（如 uuid）
- 冗余和重复的索引，没有必要的，删除
