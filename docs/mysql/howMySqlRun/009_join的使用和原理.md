# JOIN 的使用和原理

连接，就是将两个表的查询结果按相同的值连接起来。首先确定的表是驱动表，另一个表是被驱动表。

连接的过程是，每查到一条驱动表中的数据，就立即查一次被驱动表的记录进行拼接。

## 基本使用

- 内连接：如果 **关联关系** 在某一个表中不存在，就 **不显示** 为结果集，这是内连接。（场景：没参加某学科考试的学生不展示）
- 外连接：即使 **驱动表** 中的记录在被驱动表中不存在关联记录，也需要返回结果集，这是外连接。
  - 外连接才分：左连接、右连接。又叫左外连接、右外连接。（内连接邹游等效，不在乎谁是主动或被动）
- 完全连接：只有 ON 条件，没有 WHERE 条件
- 交叉连接：是没有 ON 条件的内连接，又叫笛卡尔积连接。用 `CORSS JOIN`, `逗号`, `或不加 ON 条件的内连接`。

内外连接的差别：

- 无论是 内连接 还是 外连接，都有一个是 驱动表 一个是 被驱动表（只是内连接在表象上不分驱动与被驱动）。
- 外连接时，左连接是左边是驱动表；右连接时右边是驱动表。只是查询方式不同，所以优化器会先全转换成左连接查询。
- 内连接和外连接的主要差别是：如果没有匹配的字段是否还需要显示驱动表的信息，内连接不显示，外连接将被驱动表信息显示为 null。

内连接语法：

- `select * from t1 JOIN t2 ON ...`
- `select * from t1 INNER JOIN t2 ON ...`
- `select * from t1 CROSS JOIN t2 ON ...`
- `select * from t1, t2 ON ...`

> 特别注意，交叉连接是没有 ON 条件的内连接，所以要注意在大表上的使用。

外连接语法：

- `select * from t1 LEFT [OUTER] JOIN t2 ON {join_condition} [where {filter}]`
- `select * from t1 RUGHT [OUTER] JOIN t2 ON {join_condition} [where {filter}]`

## JOIN 原理

- 循环嵌套连接：每查一条数据，进行一次跨表查询进行连接（最笨拙）
- 利用索引连接：即查询被驱动表数据时用索引去查，能加快连接速度
- 基于块的嵌套循环连接：将**驱动表数据**一次加载一大块（或全部）到 Join Buffer（连接缓冲区）中，然后扫描被驱动表匹配当前块中数据

> 这里说的块，叫做 Join Buffer，连接缓冲区。因为每查一条驱动表数据就跨表扫一次被驱动表很低效，所以将驱动表中一***块***多条记录加载到内存中，然后批量去查找被驱动表。

补充：

- 循环嵌套连接，对于驱动表的每条数据都会进行 ***被驱动表*** 的全表查询（最笨拙）
- 基于块后的循环嵌套连接，每针对于一个块进行一次 ***被驱动表*** 的全表查询
- 基于块后的循环嵌套连接，最好也在被驱动表上加索引进行命中
- Join Buffer 中会只存放查询列和过滤条件的列，所以查询不要用 *

> 注意：连接查询的过程不是先查到驱动表的所有数据再去查被驱动表，而是每查到驱动表的一条数据立即去被驱动表查询。

## 外连接消除

前提知识：
- 内连接的查询会更高效。因为优化器有更多的灵活性选择连接方式从而降低 IO 消耗。
- 内外连接的本质差别在于：在被驱动表中匹配不到数据时，驱动表的记录还显示不显示的差别。

当在使用外连接查询中，如果查询条件确保了认被驱动表不存在 NULL 的记录，那么两种连接查询的结果是一样的，就可以使用内连接。

> 例子：
> a 为学生信息表，b 为某次考试成绩表
> 如果小红没有参加考试，那么要查询所有学生（包含未参加考试的同学）的考试情况就需要用外连接，
> 而如果要查询考试满分的同学，那么这个查询就可以为内连接。
