# InnoDB 行结构

> 存储结构：页，页中有行

## 前提知识

InnoDB 生成主键的策略：

- 优先使用 **自定义主键**
- 其次选一个 **不允许 NULL 的 UNIQUE 键**
- 再次使用隐藏列（就是下问中的 `ROW_ID`，此列是可能不存在的）

MySQL 中有四种不同类型的行格式：

- COMPACT: 紧凑的
- REDUNDANT: 赘余的
- DYNAMIC: 动态的
- COMPRESSED: 压缩的

一般行结构，大体分两段，前段记录额外信息；后段记录真实的列值。

其中额外信息中关于列的列表都是 **逆序存放** 的（和列值关于分界线对称），原因：为了方便从 记录头信息处，向左查能依次查到列信息，向右查能查到真实值。

列值中 MySQL 还会为每个记录添加一些隐藏列（在行记录真实列前）：`ROW_ID`、`TRX_ID`、`ROLL_POINTER`（行 ID、事务 ID、回滚指针）。

## COMPACT 紧凑的

额外信息依次包括：***变长字段长度列表***、***NULL 值列表***、***记录头信息***

- 变长字段长度列表：存储变长字段的长且 **非 NULL 列** 的长度信息，**逆序列表** 存放。变长类型包含 VARCHAR、VARBINARY、TEXT、BLOB 类型。
- NULL 值列表：一个二进制位按列顺序 **逆序排列**
- 头信息：固定大小 **5 字节**，标记是否删除、是否为最小目录项、此记录在页对中的相对位置、当前记录的类型、下一条记录相对位置

```
┌────────────────────┬────────────┬───────────╦────────────┐
│  变长字段长度列表   │ NULL 值列表 │ 记录头信息 ║ 列值列表... │   ┼
└────────────────────┴────────────┴───────────╩────────────┘
```

> 对于变长 CHAR(M) 类型，规定列至少占用 M 个字节的空间。注意是 M 个字节，如 M 个 3 字节 CHAR 时，需要空间会是 3M。

## REDUNDANT 赘余的

- 额外信息依次包括：***字段长度偏移列表***、***记录头信息***
- 即，记录 ***所有字段*** 的 ***尾巴*** 的 ***偏移量***
- 这样的话，每个字段的长度，就是 `本字段偏移量 - 前字段偏移量`

NULL 值处理：使用列对应偏移列表中首个 bit 标记，也叫 **NULL 比特位**。

```
┌────────────────┬────────────╦─────────────┐
│  字段偏移列表   │  记录头信息 ║ 列值列表...  │   ┼
└────────────────┴────────────╩─────────────┘
```

<!-- ╔ ═  ╤ ╗ ║ ╟ ─ ┼ ╢ ╚ ╧ ╝ -->

## 溢出列处理

对于 COMPACT 和 REDUNDANT 行格式中，对于占用存储空间很大的列，会将 768字节外剩余信息存储到其他页（溢出页）中，在本记录中真实数据处后方的 20字节存储地址。

## DYNAMIC 和 COMPRESSED 行格式

这两个行格式与 COMPACT 类似，只在处理溢出列处不同。此两种将溢出者所有数据都存储到溢出页中。

另外 COMPRESSED 行格式还会使用压缩算法将 **页** 压缩。

## 总结

- Compact 行格式，存储变长字段长度列表、NULL 值列表、记录头信息
- Redundant 行格式，存储偏移量的列表、记录头信息
- 溢出列处理：上两种都是讲 768 之外的字节存储到溢出页中
- Dynamic 和 Compact 与 Compact 不同在溢出列完全存放在在溢出页（三种都是紧凑的）
- 以及 Compact 会压缩 **页**

---

## 记录头信息

记录头信息有一些关键的标记

- deleted_flag: 标记是否被删除
- heap_no: 标记记录在页（页堆）中的相对位置
- next_record: 下一个记录的相对位置
- record_type: 当前记录的类型：0 普通记录、1 非叶节点目录项记录、2 Infimum 记录、3 Supremum 记录
- min_rec_flag: 是否为 B+ 树中当前层最小目录项
- n_owned: 非零表示为 组 中的第一个记录，值表示组中有多少记录

特性：

- 记录删除后，会用 delete_flag 标记，然后用 next_record 形成一个单独的垃圾链表，
- 记录在页中顺序紧凑排列，heap_no 递增，行记录从 2 开始，因为 0、1 用于 Infimum、Supremum 记录。
- Infimum、Supremum 记录也是两个行记录，只不过值是固定的，但头信息按原则来。
- 页中所有行记录用 next_record 形成单向链表，以 Infimum 开始，以 Supremum 结束。
- next_record 存储的是下一个记录到本记录的距离值（可能是负数），认为是链表就行，只是维护方式不同
- 组 是页中又做了个块划分，又叫 槽。也就是说，页 - 组 - 记录，分三层，为的是快速寻找
