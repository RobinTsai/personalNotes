# 查询性能优化

SQL 语句执行顺序：

- 1 from        表名
- 2 join        关联表
- 3 on          关联条件
- 4 where       筛选条件
- 5 group by    分组字段
- 6 having      分组后筛选条件
- 7 select      列名
- 8 order by    排序字段
- 9 limit       输出限制

提纲：优化器是如何工作的；哪些工作有风险，如何规避。

## 为什么查询速度会慢

查询的生命周期：从客户端，到服务端，然后在服务器上执行解析，生成执行计划，执行，并返回结果给客户端。其中“执行”是生命周期中最重要的阶段，包括了大量为了检索数据到存储引擎的调用已经调用后的数据处理，包括排序、分组等。

花费事件的地方：网络、CPU计算、生成统计信息和执行计划、锁等待等；尤其是像底层存储引擎检索数据的调用，需要在内存中操作、CPU操作和内存不足时导致的 IO 操作上消耗事件，根据引擎不同，可能还会产生大量的上下文切换和系统调用。

## 优化数据访问

最基本的一个原因：访问的数据太多。

通过两个步骤分析查询是否高效精准：

- 是否检索了大量不需要的数据，通常是访问了太多的行，有时候也是访问了太多的列。
- 确认是否服务层在分析大量不需要的行。

### 是否向数据库请求了不需要的数据

- 影响：网络开销，cpu 和内存开销
- 经典案例：
  - 查询了不需要的行
  - 多表关联时返回全部的列
  - 总是取出全部的列
  - 无缓存，重复查询相同的数据

### 是否额外扫描了不需要的行

完美场景是所查即所得。

Explain 语句中的 type 列反应了访问类型，由慢到快：全表扫描（ALL）、索引扫描、范围扫描、唯一索引查询、常数引用等。

三种 where 条件由好到坏依次为：

- 在索引中使用 WHERE 条件是引擎层完成的；
- 索引覆盖扫描（Extra: Using index）是在服务层完成的，无需再回表查询记录；
- 服务层过滤数据（Extra: Using where）

差案例：

- `select actor_id, count(*) from sakila.film_actor group by actor_id;`
- 这个查询需要读取几千行数据，但仅返回 200 行结果
- 没有什么索引能够减少这样的查询需要扫描的行数

如何解决查询需要扫描大量行但返回少数的行：

- 使用索引覆盖扫描，把所有需要的列都放到索引中
- 改表库表结构，使用单独的汇总表
- 重写复杂的查询（下文）

## 重构查询方式

### 用一个查询代替多个查询

- MySQL 扫描行很高效，相比来说，响应数据就慢得多。
- 所以用一条查询代替 10 条查询很有必要

### 切分查询

- 有时候需要分而治之，尤其是在发生 锁 的时候
- 如删除旧数据会一次所著很多数据，沾满整个事务日志、耗尽系统资源、阻塞其他重要查询
- 此时，将大语句按块切分执行很有必要

### 分解关联查询（无用）

在考虑如下好处时可以分解关联查询为多条查询

- 让缓存的效率更高：如使用 join 时单个查询语句返回结果很少
- 减少锁的竞争
- 用 IN 替换查询，让 MySQL 按 ID 顺序查找
- 减少冗余记录的查询：在用 join 时可能重复地访问一部分数据
- 实现了哈希关联

## 查询执行的基础

补充图一张

### MySQL 客户端/服务器通信协议

- 这里 C/S 模型是 **半双工** 的，即请求和响应不能同时进行（无法做流量控制）
- 客户端用 **一个单独的数据包** 将查询传给服务器，参数 `max_allowed_packet` 控制了其大小。
- 服务端响应通常由多个数据包组成，只有在发送完全后才能停止及释放所有占用资源（客户端无法停止服务器的响应，断开连接也不行）
- 多数库函数也是查询完全的数据缓存下来后才分段返回的，如 `while ($row = mysql_fetch_array(mysql_query(xxx)) )`
- 可以使用 `SHOW FULL PROCESSLIST` 命令查询连接的状态（sleep 等待、query 执行查询、locked 等待锁、analyzing and statistics 正在收集统计信息并生成查询计划等等）

### 查询缓存

任何一个字节不同则无法使用缓存

### 查询优化处理

## 优化特定类型查询

### Count

- Count 是个特殊的函数，可以统计某个列值的数量，也可以统计行数
- 在统计列值时要求列值非空的（不统计 NULL）
- 统计表行数时不要加特定的列（可能 NULL 引发查询不预期）
- Count 在没有 WHERE 条件时才非常快，因为不需要实际计算
- 有时候用 `Count(全量) - Count(小部分)` 速度优于 `Count(大部分)`
  - `SELECT (SELECT COUNT(*) FROM T) - COUNT(*) FROM T WHERE ID < 5;`
- 使用 EXPLAIN 获取近似值：在不要求精确而查询又耗资源的时候

> 对 NULL 的误解：
> NULL 与任何非 NULL 值比较会返回 Unknown，而非 True/False

### 关联

- 在使用 ON 和 USING 时确保此列上有索引
- 在第二个列上创建索引：第一个列会全表扫描，第二个列
- Order By 和 Group By 只用一个表上存在的索引，这样可以命中索引
- 升级 MySQL 的时候要注意，可能关联语法、运算符优先级等发生变化

### 子查询

- 尽可能（并发绝对）用关联查询代替子查询

### 优化 Group By 和 DISTINCT

- 尽可能地使用索引，这是效率最高的
- 当无法使用索引的时候，Group By 有两种策略：
  - 临时表
  - 文件排序
- 可以使用提示 SQL_BIG_RESULT 和 SQL_SMALL_RESULT 来让优化器按期望的方式运行

### 优化 limit 分页

- 语法 `limit [offset,] count`
- 头疼问题点：在偏移量非常大的时候，如跳过前 10000 条后取 20 条 `limit 10000, 20`
  - 优化点一：限制分页的数量
  - 优化点二：优化大偏移量性能（因为先 select 再 order 最后 limit）
    - 使用索引覆盖（非覆盖时，所有 offset 内也会发生回表）
    - 使用“延迟关联”：先用 join 子句覆盖索引查出 id，然后主句查询更多字段。
    - 使用主键记录作为标记进行翻页
- 避免使用 SQL_CALC_FOUND_ROWS hint，它用于查询匹配条件的总行数，但总会扫描满足条件的所有行然后抛弃不需要的行，代价很高

### 优化 Union

- MySQL 总是通过 创建并填充临时表的方式来执行 Union 查询（事实上所有查询都是通过临时表存放，然后读出返回给客户端）。
- 总是需要手工地将 WHERE、LIMIT、ORDER BY 等子句“下推”到 UNION 的各个子查询中进行优化
- 除非确实需要服务器消除重复的行，否则一定要使用 UNION ALL 关键字，因为如果没有 ALL 关键字，MySQL 会给临时表加上 DISTINCT 选项，对临时表数据做唯一性检查，代价很高
