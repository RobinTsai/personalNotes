# 高性能索引

索引性能与数据量有关。数据量越大，越需要最优索引。

索引在存储引擎层实现。

> 如果使用 ORM，是否还需要关心索引？
> 这个说法的由来：

## 索引的类型


- B-Tree 索引
- 哈希索引
- 空间数据索引（R-Tree）
- 全文索引
- 其他索引类别

### B-Tree 索引

实际上很多存储引擎使用的是 B+Tree，InnoDB 使用的也是 B+Tree。即每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的遍历。

> 习惯称 B-Tree 是因为在 MySQL 大多数语句中都是用 BTREE 关键字。如 `CREATE TABLE xxx USING BTREE;`

B-Tree 中所有数据（包含所有列）组成一个大树，中间节点也可以包含行数据，节点横向之间没有指针；B+Tree 只将关键列形成一个大树，叶子节点有横向的指针。

B-Tree 索引适用于 全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。


### 哈希索引

```sql
CREATE TABLE testhash (
    fname VARCHAR(50) NOT NULL,
    lname VARCHAR(50) NOT NULL,
    KEY USING HASH(fname)
) ENGINE=MEMORY;
```

原理：用索引列的哈希值创建索引，索引中只包含哈希值和行指针；用链表解决哈希冲突。

优点：查询速度快（除非有大量哈希冲突），空间小。

限制：

- 只能在精确匹配时用得上索引。
- 只有 Memory 引擎 **显式** 支持哈希索引。
- 链表查询要扫描行；
- 无法排序查找，因为用哈希值排序而非原始值排序。
- 不支持部分索引列匹配查找（不支持最左前缀匹配），如在 (A, B) 两列上建立哈希索引，那么只查 A 列无法命中索引。
- 只支持等值比较查询（存储不是按值排序的）
- 哈希冲突很多的时候，维护代价会很高（主要是遍历的成本）

自适应哈希索引：是 InnoDB 引擎有个特殊功能，当 InnoDB 主要到某些索引值很频繁被使用时，他会在内存中基于 B-Tree 索引在创建一个哈希索引，优化查询效率（内部的、自动的行为，只有关闭开关）。

伪哈希索引：如果在 InnoDB 中想用哈希索引，可以用哈希函数创建一个 伪哈希索引，即用 哈希函数计算出值的列 再创建此列索引（可以用触发器）。

- 创建在 Where 语句中总是加上 哈希函数 来进行查询（实际是用哈希值做了 B-Tree 结构的索引）。
- 同时注意哈希冲突，需要在查询上再加上原值查询。
- 可以用触发器自动 SET 这个哈希值列，或手动计算哈希存列
- 哈希函数的选择 CRC32() 计算结果小，但容易产生冲突；SHA1/MD5 计算结果大，浪费空间；也可以自己实现哈希算法

空间数据索引（R-Tree）：MyISAM 支持空间索引，可用于地理数据存储。

全文索引：是一种特殊的索引，匹配方式和其他完全不一样，查询方式用 MATCH AGAINST。它查找文本中的关键字而不是直接比较索引中的值。在相同列上同时创建全文索引和基于值的 B-Tree 索引不会有冲突。

其他索引类别：
