# 高性能索引

索引性能与数据量有关。数据量越大，越需要最优索引。

索引在存储引擎层实现。

> 如果使用 ORM，是否还需要关心索引？
> 这个说法的由来：

## 索引的类型


- B-Tree 索引
- 哈希索引
- 空间数据索引（R-Tree）
- 全文索引
- 其他索引类别

### B-Tree 索引

实际上很多存储引擎使用的是 B+Tree，InnoDB 使用的也是 B+Tree。即每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的遍历。

> 习惯称 B-Tree 是因为在 MySQL 大多数语句中都是用 BTREE 关键字。如 `CREATE TABLE xxx USING BTREE;`

B-Tree 中所有数据（包含所有列）组成一个大树，中间节点也可以包含行数据，节点横向之间没有指针；B+Tree 只将关键列形成一个大树，叶子节点有横向的指针。

B-Tree 索引适用于 全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。


### 哈希索引

```sql
CREATE TABLE testhash (
    fname VARCHAR(50) NOT NULL,
    lname VARCHAR(50) NOT NULL,
    KEY USING HASH(fname)
) ENGINE=MEMORY;
```

原理：用索引列的哈希值创建索引，索引中只包含哈希值和行指针；用链表解决哈希冲突。

优点：查询速度快（除非有大量哈希冲突），空间小。

限制：

- 只能在精确匹配时用得上索引。
- 只有 Memory 引擎 **显式** 支持哈希索引。
- 链表查询要扫描行；
- 无法排序查找，因为用哈希值排序而非原始值排序。
- 不支持部分索引列匹配查找（不支持最左前缀匹配），如在 (A, B) 两列上建立哈希索引，那么只查 A 列无法命中索引。
- 只支持等值比较查询（存储不是按值排序的）
- 哈希冲突很多的时候，维护代价会很高（主要是遍历的成本）

自适应哈希索引：是 InnoDB 引擎有个特殊功能，当 InnoDB 主要到某些索引值很频繁被使用时，他会在内存中基于 B-Tree 索引在创建一个哈希索引，优化查询效率（内部的、自动的行为，只有关闭开关）。

伪哈希索引：如果在 InnoDB 中想用哈希索引，可以用哈希函数创建一个 伪哈希索引，即用 哈希函数计算出值的列 再创建此列索引（可以用触发器）。

- 创建在 Where 语句中总是加上 哈希函数 来进行查询（实际是用哈希值做了 B-Tree 结构的索引）。
- 同时注意哈希冲突，需要在查询上再加上原值查询。
- 可以用触发器自动 SET 这个哈希值列，或手动计算哈希存列
- 哈希函数的选择 CRC32() 计算结果小，但容易产生冲突；SHA1/MD5 计算结果大，浪费空间；也可以自己实现哈希算法

空间数据索引（R-Tree）：MyISAM 支持空间索引，可用于地理数据存储。空间索引无需前缀查询，会从所有维度来索引数据。

全文索引：是一种特殊的索引，匹配方式和其他完全不一样，更类似于搜索引擎做的事，查询方式用 MATCH AGAINST。它查找文本中的关键字而不是直接比较索引中的值。在相同列上同时创建全文索引和基于值的 B-Tree 索引不会有冲突。

其他索引类别：略。

## 索引的优点

- 大大减少需要扫描的数量
- 避免排序和临时表
- 将随机 IO 变为顺序 IO

> 索引完全可以单独写一本书《Relational Database Index Design and the Optimizers》，详细介绍了如何计算索引的成本和作用、如何评估查询速度、如何分析索引维护的代价和带来的好处等。


## 高性能索引的策略

### 独立的列

独立的列不是指创建一个单独列的索引，而是指索引列要在 WHERE 语句中独立使用，不能是表达的一部分，也不能是函数的参数。

### 前缀索引和索引的选择

前缀索引是指用 **列值的前缀** 做索引，尤其是一个大值的列，如 BLOB、TEXT、长 VARCHAR 类型必须使用前缀索引，MySQL 不允许索引这些列的完整长度。

前缀索引可以

- 优：减小索引大小
- 缺：排序不准确（ORDER BY）
- 缺：不能分组（GROUP BY）
- 缺：无法覆盖索引查询

如何选用前缀

关键在于 **找基数**：找到数据集真实分布（也可以最频繁出现的），对比前缀数据集的分布，当前缀长度的选择性越接近与完整列的选择性的时候，就是合适的前缀长度。

### 使用多列索引

- 典型的错误：为每个列创建独立的索引，或按照错误的顺序创建多列索引。

在多个列上创建独立的单列索引大部分情况下不能提高查询性能，但 MySQL 5.0 及之后引入了 **索引合并** 的策略，一定程度上可以用多个单列索引定位指定的行。

索引合并有三个变种：OR 条件的联合，AND 条件的相交，组合前两种情况的联合和相交。通过 EXPLAIN 中的 Extra: Using Union(Idx1, Idx2)... 可以看到这点。

索引合并是一种优化结果，但同时反应出建立索引的糟糕：

- 当出现多个索引相交的查询时，意味着需要一个包含所有列的多列索引
- 当服务器做了联合操作时（通常多个 OR）需要耗费大量 CPU 和 内存在算法的缓存、排序和合并操作上
- 优化器不会将这些计算到 **查询成本** 中，会使得查询成本被低估，可能还不如直接走全局扫描
- 可以使用参数 optimizer_switch 关闭索引合并功能

### 选择合适的索引列顺序

- 在不考虑排序和分组时，将 **选择性最高** （筛查精度最高）的列放在前面通常是很好的

### 聚簇索引

聚簇索引不是一种索引类型，而是一种数据存储方式。它是将数据行和相邻的键值紧凑地存储在一起（叶子节点有全部的行数据）。

由于数据行和索引键值存储在一块，所以一个表只能有一个聚簇索引。其他的索引都叫二级索引。

MySQL 中聚簇索引：

- 一般是主键索引
- 没有主键时，会选择一个唯一、非空的索引代替
- 如果还没有，会隐式定义一个主键来做聚簇索引

聚簇索引的优点：

- 顺序 IO
- 数据访问更快：索引和行数据在一个 B-Tree 中，比其他二级索引更快查询
- 覆盖索引扫描的查询可以直接使用页节点中的主键值

缺点：

- 如果数据全部放到内存中，不发生 IO 就没有优化作用
- 插入速度严重依赖于插入顺序：不是按主键顺序插入会慢
- 更新聚簇索引**列**的代价很高：每个被更新的行会移到新的位置
- 插入新行或主键更新导致行迁移的时候可能发生 **页分裂**，进而产生更多碎片
- 可能导致全表扫描变慢，尤其是页分裂导致行稀疏的时候
- 二级索引可能更大：因为二级索引的叶子节点引用了行的主键列
- 二级索引需要两次查询才能查找到行：第一次从二级索引中找到主键，第二次用主键查聚簇索引找到行数据

可以说，InnoDB 的聚簇索引就是整个表，包含了主键值、事务ID、回滚指针、所有剩余列。

> MyISAM 中主键索引不是聚簇索引，由于它总是按顺序存储在磁盘上，及行是定长的，所以用行号进行标记位置。
> 可以说 MyISAM 中的主键索引和二级索引没什么差别，其叶子节点都存储的是数据行的行号。

注意点：

- 避免用随机的值做聚簇索引的主键：如用 UUID 做主键，由于要维持顺序，每一个新增都是插入，这将非常糟糕，会造成大量页分裂和碎片，进而插入速度慢，索引占用空间大等一系列问题。用作二级索引没问题。

### 覆盖索引

如果一个查询，命中了索引，且所有字段都在索引表中获取得到，那么就是“覆盖索引”。覆盖索引无需回表。

在 Explain 中 Extra 字段表示为 `Using index`

优点：

- 只需要读取索引，减少数据访问量
- 顺序 IO（最起码单页内顺序 IO）
- 部分引擎用内存缓存索引（如 MyISAM），直接内存访问，减少系统调用
- 二次索引避免了回表查询

### 索引下推

> 版本 5.6 之后有了索引下推。5.6 之前存储引擎的 API 不允许将过滤条件传到存储引擎层。

索引下推是将 where 中的过滤条件下推到引擎层来执行。

没有索引下推时，存储引擎根据索引找到满足部分条件的记录后，会将这些记录的整行数据返回从磁盘读到内存中，然后返回给服务器层，由服务器层判断其他非索引列的条件是否满足。

有了索引下推之后，存储引擎在扫描索引时，对于可以利用索引中已有信息来判断的条件，直接在存储引擎层进行判断，只有满足所有可下推条件的索引记录，才会被用于回表查询数据并返回给服务器层。即将原本在服务器层做的判断下推到了存储引擎层，在索引扫描阶段提前过滤了不满足条件的记录，减少回表和数据传输的开销。

> 大部分查到的例子都是关于 `like "xxx%"` 的

### 使用索引扫描做排序

Explain 中的 type 列，表明如何查找行，值为 index 时说明使用了索引扫描来做排序。

只有当 索引列的顺序 和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向都一致时，才会用索引进行排序。

### 压缩（前缀压缩）索引

MyISAM 使用前缀压缩来减少索引的大小，从而让索引可以放入内存中。默认只压缩字符串，参数设置可以对整数做压缩。

### 冗余和重复索引

MySQL 允许在相同列上创建多个索引，会单独维护重复的索引，优化器在优化查询的时候会逐个考虑，影响性能。

重复索引一定无用，看到后应立即删除。冗余索引是被另一个索引包含的索引，在 MyISAM 中是有用的，因为 MyISAM 有索引压缩，所以没有最左匹配原则不生效；在 InnoDB 中是无用的。

### 未使用的索引

未使用的索引可以通过查询使用频率将其删除，查询方法：

- Percona Server 和 MariaDB 先打开 userstates 服务器变量
- 通过查询 INFOMATION_SCHEMA.INDEX_STATISTICS 查看每个索引使用频率

### 索引和锁

少有人知的细节：InnoDB 在二级索引上使用共享锁（读锁），但访问主键索引需要排他锁（写锁）。

索引可以让查询锁定更少的行。

一般的查询是引擎层检索到数据并返回给服务器层后，服务器应用 Where 语句。Explain 时 Extra 列显示 `Using where`

### 多种过滤条件

诀窍。

- 枚举值索引列不限制时怎么命中索引：如，某查询不限制性别，但性别在索引列中，不填写时无法命中索引，可以用 `SEX IN('m', 'f')` 填充使其命中索引，但枚举太多时效率会变差。
- 让范围查询放在后面：由于查询只能使用索引的最左前缀，直到遇到第一个范围查询。尽可能将范围查询的列放到索引后面。
- 确保 IN 的组合要小于千级别：每增加一种 IN 条件，优化器需要做的组合成指数增加，注意全组合要小于千级别。新版本 MySQL 在组合超过一定量后不再进行执行计划评估了。

### 优化排序

- 利用索引来优化排序
- offset 太多：如用 `limit 100000, 10`（跳过 100000 数据，取 10 行），MySQL 会用大量时间来丢弃数据。
  - 反范式化、预先计算和缓存，是解决这些问题的好方法
  - 更好的方法是限制用户能够翻页的数量（很少有用户会真正在乎第 10000 页的数据）
  - 另一个好方法是延迟关联：通过覆盖索引返回需要的主键，再根据主键需要的行

## 维护索引和表

### 表损坏

在 MyISAM 引擎中，表损坏通常是系统崩溃导致的（因为 MyISAM 先写内存，再同步到磁盘，没有 Writing Ahead）

损坏的索引会导致查询返回错误的结果，或者莫须有的主键冲突等问题，甚至直接导致数据库崩溃。

检查方法：`CHCEK TABLE` 命令（部分存储引擎不支持此命令，或需要不同的选项，没有什么查询能够让 InnoDB 表损坏，一般是硬件问题）

修复方法：`REPAIR TABLE` 命令（部分索引支持），或使用 `ALTER` 操作重新建表，如修改引擎；再或者使用其他工具导出再导入。

### 索引统计信息

MySQL 优化器的使用是 **基于成本** 的模型，这个成本的指标就是 **查询需要扫描多少行**。

这个信息从索引的统计信息中获取，如果统计信息不准确，或者执行计划本身太复杂以致于无法准确获取各阶段匹配行数，可能导致错误的判断。

查询优化器会通过两个 API 来了解存储引擎的索引值的分布信息（存储引擎提供的两个 API）。

- 第一个 API 是 `records_in_range()`，通过向存储引擎传入两个边界值，获取在这个范围大约有多少记录。
- 第二个 API 是 `info()`，返回各种信息，包含索引的基数情况（每个键值有多少条记录）。

可以通过 `ANALYZE TABLE` 来重新生成统计信息。这也是有成本的：

- Memory 引擎不存储统计信息；
- MyISAM 会进行一次全索引扫描，整个过程要锁表；
- InnoDB 在 5.5 版本后不在磁盘中存储索引统计信息，而是通过随机的索引访问进行评估存在内存中。

可以通过 `SHOW INDEX FROM` 命令查看索引的基数（Cardinality），在 5.0 版本之后也可以通过 `infomation_schema.statistics` 表方便的查询。

InnoDB 生成统计信息的方式：通过抽样的方式，首先随机读取少量索引页面，然后以此为样本计算索引的统计信息。

InnoDB 生成统计信息可能发生很严重的问题：

- 触发统计信息更新的时机：InnoDB 在表首次打开；或者执行 `ANALYZE TABLE`；或者表大小发生非常大的变化（超过 1/16 或插入了 20亿行数据）；或者在打开某些某些 `INFORMATION_SCHEMA`；或者使用 `SHOW TABLE STATUS` 或 `SHOW INDEX`；或在客户端开启自动补全功能的时候。
- 发生严重问题：尤其是 IO 比较慢的时候；采样更新时会发生大量的锁，给服务器额外的压力。
- 如何解决：可以关闭 `innodb_stats_on_metadata` 参数避免上述问题

### 减少索引和数据的碎片

- 碎片化会降低查询的效率
- 三种碎片：
  - 行碎片：数据行被存储到多个地方的多个片段。即便查询只访问一行记录，行碎片也会导致性能下降。
  - 行间碎片：数据行在磁盘上不是顺序存储。在全表扫描、聚簇索引扫描的操作时使用 随机 IO 导致效率不高。
  - 剩余空间碎片：数据页中有大量的空闲空间。导致服务器读取大量不需要的数据，造成浪费。
- 优化碎片：使用 `OPTIMIZE TABLE` 或导出再导入的方式重新整理数据。

## 总结

索引是一个非常复杂的话题，可以单独出一本书。当前记住三个原则：

- 单行访问是很慢的：服务器从存储中读取一个数据块只是为了读取其中一行，那么就浪费了很多工作，索引可以创建位置引用提高效率。
- 顺序访问范围数据是很快的：一是顺序 IO 避免多次磁盘寻道；二是不再需要额外的排序工作；并且 GROUP BY 页不需要做排序和聚合计算。
- 索引覆盖查询时很快的：不再需要回表，避免了大量的单行访问。
