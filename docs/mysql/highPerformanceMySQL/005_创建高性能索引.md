# 高性能索引

索引性能与数据量有关。数据量越大，越需要最优索引。

索引在存储引擎层实现。

> 如果使用 ORM，是否还需要关心索引？
> 这个说法的由来：

## 索引的类型


- B-Tree 索引
- 哈希索引
- 空间数据索引（R-Tree）
- 全文索引
- 其他索引类别

### B-Tree 索引

实际上很多存储引擎使用的是 B+Tree，InnoDB 使用的也是 B+Tree。即每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的遍历。

> 习惯称 B-Tree 是因为在 MySQL 大多数语句中都是用 BTREE 关键字。如 `CREATE TABLE xxx USING BTREE;`

B-Tree 中所有数据（包含所有列）组成一个大树，中间节点也可以包含行数据，节点横向之间没有指针；B+Tree 只将关键列形成一个大树，叶子节点有横向的指针。

B-Tree 索引适用于 全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找。


### 哈希索引

```sql
CREATE TABLE testhash (
    fname VARCHAR(50) NOT NULL,
    lname VARCHAR(50) NOT NULL,
    KEY USING HASH(fname)
) ENGINE=MEMORY;
```

原理：用索引列的哈希值创建索引，索引中只包含哈希值和行指针；用链表解决哈希冲突。

优点：查询速度快（除非有大量哈希冲突），空间小。

限制：

- 只能在精确匹配时用得上索引。
- 只有 Memory 引擎 **显式** 支持哈希索引。
- 链表查询要扫描行；
- 无法排序查找，因为用哈希值排序而非原始值排序。
- 不支持部分索引列匹配查找（不支持最左前缀匹配），如在 (A, B) 两列上建立哈希索引，那么只查 A 列无法命中索引。
- 只支持等值比较查询（存储不是按值排序的）
- 哈希冲突很多的时候，维护代价会很高（主要是遍历的成本）

自适应哈希索引：是 InnoDB 引擎有个特殊功能，当 InnoDB 主要到某些索引值很频繁被使用时，他会在内存中基于 B-Tree 索引在创建一个哈希索引，优化查询效率（内部的、自动的行为，只有关闭开关）。

伪哈希索引：如果在 InnoDB 中想用哈希索引，可以用哈希函数创建一个 伪哈希索引，即用 哈希函数计算出值的列 再创建此列索引（可以用触发器）。

- 创建在 Where 语句中总是加上 哈希函数 来进行查询（实际是用哈希值做了 B-Tree 结构的索引）。
- 同时注意哈希冲突，需要在查询上再加上原值查询。
- 可以用触发器自动 SET 这个哈希值列，或手动计算哈希存列
- 哈希函数的选择 CRC32() 计算结果小，但容易产生冲突；SHA1/MD5 计算结果大，浪费空间；也可以自己实现哈希算法

空间数据索引（R-Tree）：MyISAM 支持空间索引，可用于地理数据存储。空间索引无需前缀查询，会从所有维度来索引数据。

全文索引：是一种特殊的索引，匹配方式和其他完全不一样，更类似于搜索引擎做的事，查询方式用 MATCH AGAINST。它查找文本中的关键字而不是直接比较索引中的值。在相同列上同时创建全文索引和基于值的 B-Tree 索引不会有冲突。

其他索引类别：略。

## 索引的优点

- 大大减少需要扫描的数量
- 避免排序和临时表
- 将随机 IO 变为顺序 IO

> 索引完全可以单独写一本书《Relational Database Index Design and the Optimizers》，详细介绍了如何计算索引的成本和作用、如何评估查询速度、如何分析索引维护的代价和带来的好处等。


## 高性能索引的策略

### 独立的列

独立的列不是指创建一个单独列的索引，而是指索引列要在 WHERE 语句中独立使用，不能是表达的一部分，也不能是函数的参数。

### 前缀索引和索引的选择

前缀索引是指用列值的前缀做索引，尤其是一个大值的列，如 BLOB、TEXT、长 VARCHAR 类型必须使用前缀索引，MySQL 不允许索引这些列的完整长度。

前缀索引可以

- 优：减小索引大小
- 缺：排序不准确（ORDER BY）
- 缺：不能分组（GROUP BY）
- 缺：无法覆盖索引查询

如何选用前缀

关键在于 **找基数**：找到数据集真实分布（也可以最频繁出现的），对比前缀数据集的分布，当前缀长度的选择性越接近与完整列的选择性的时候，就是合适的前缀长度。

### 多列索引

#### 典型的错误

一种常见的错误是，为每个列创建独立的索引，或按照错误的顺序创建多列索引。

在多个列上创建独立的单列索引大部分情况下不能提高查询性能，但 MySQL 5.0 及之后引入了 **索引合并** 的策略，一定程度上可以用多个单列索引定位指定的行。

索引合并有三个变种：OR 条件的联合，AND 条件的相交，组合前两种情况的联合和相交。通过 EXPLAIN 中的 Extra: Using Union(Idx1, Idx2)... 可以看到这点。

索引合并时一种优化结果，但同时反应出索引建的糟糕：

- 当出现多个索引相交的查询时，意味着需要一个包含所有列的多列索引
- 当服务器做了联合操作时（通常多个 OR）需要耗费大量 CPU 和 内存在算法的缓存、排序和合并操作上
- 优化器不会将这些计算到 **查询成本** 中，会使得查询成本被低估，可能还不如直接走全局扫描
- 可以使用参数 optimizer_switch 关闭索引合并功能

##### 选择合适的索引列顺序

- 在不考虑排序和分组时，将 **选择性最高** （筛查精度最高）的列放在前面通常是很好的
