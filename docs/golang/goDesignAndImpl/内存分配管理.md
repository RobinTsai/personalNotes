# Go 的内存分配管理

特点：细微的对象切割；极致的多级缓存；精准的位图管理。

## span 和分配的元素

- 67 个级别的 span。
- 0 级（class）代表特殊的大对象
- 分配对象时根据对象的大小，在对应级别的 span 中分配
- 最小级别的 1 级，用 8K 大小的 span，最小元素大小是 8B（因此可申请 1024 个元素）

## 三级对象的管理

三个级别（三个级别再下层就是操作系统的虚拟内存了）：

- mcache（线程缓存）: 每个 P 独有，访问无需加锁。有所有级别的 span。每级的 span 有且只有一个，除了 0 级 span 外都是来自 mcentrl。
- mcentral（中心缓存）: 所有 P 共享，访问需要加锁。有所有级别的 span。每级有两个链表，一个链是有空闲对象链表，另一个是没有空闲对象链表。
- mheap（页堆）: 是管理内存的核心单元。其管理了 mcentral，且负责直接分配大对象。其将堆分为多个 HeapArena 进行管理。Unix 的 Arena 固定未 64M。

> 多级别的 span 可以认为是个数组

## 对象分配

对象分为三级

- 微对象：小于 16B
- 小对象：小于 32KB，大于等于 16B
- 大对象：大于等于 32KB

分配过程：

- 确定 mspan（要考虑内存对齐）
- mcache 中按 allocCache（位图）查询可用的 mspan。查到则分配，并结束。
  - allocCache 是个 64 bit 的位图，用于标记 mspan 是否被使用。顺序从低位到高位，1 标记是被使用。
- mcentral 需要加锁访问，然后先遍历无空闲元素链表的 span，然后遍历有空闲元素的 span 链表。查到则分配并结束。
  - 遍历无空闲元素的链表是因为可能垃圾回收标记为空闲但没来得及清理，则直接使用
- mheap 会先遍历 P 中 pageCache（位图）查询是否有空闲空间可分配
  - pageCache 是个 64 bit 的位图，用于标记每个 page 是否被使用。顺序从低位到高位，0 标记是被使用（和 allocCache 相反）
  - 可以寻找并分配连续的 page，即查询连续的 1.
- mheap 查找基数树找到可分配的 page：若 P 中没有空闲 page 可分配，则对 mheap 加锁，并在整个 mheap 的位图中查找可分配的 page
  - mheap 用 **基数树** 管理线性地址空间，查询树从根节点到叶子节点查到一个地址
- 向操作系统申请内存
  - 在 Unix 系统中用 mmap 向系统申请内存，申请大小必须为 heapArena 大小 64M 的倍数

总结：

- 微小对象和小对象的分配：mcache -> mcentral -> mheap 在 P 位图中查找 -> mheap 在基数树中查找 -> 向操作系统申请。
- 大对象的分配（直接从 mheap 开始）：mheap 在基数树中查找 -> 向操作系统申请。
