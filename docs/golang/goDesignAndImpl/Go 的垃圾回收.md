# Go 的垃圾回收

## 为什么需要

- 能确保不再被引用的对象被回收（开发者实现的内存泄漏没法避免）
- 避免了悬空指针
- 避免了多次释放等手动管理不善等问题
- 垃圾回收对于要求极致内存、极致速度的场景并不适用（如嵌入式、系统级程序）

## 5 中经典算法

- 引用计数：缺点，计数要原子更新，难以处理自引用
- 标记-清除：主要缺点是会产生碎片和空洞，导致新对象分配失败
- 标记-压缩（Mark-Compact）：解决了碎片问题，但通常破坏了缓存的局部性，常常需要额外的空间记录移动位置，增加了复杂性。需要加锁，影响并发性。
- 半空间复制（标记-移动）：用空间换时间，每次只用一半的内存空间，另一半用于移动压缩；消除了内存碎片，只需要扫描一次。
- 分代 GC：按对象存活时间进行划分，死去的一半都是新生的，旧对象在 fullGC 时回收。

## Go 的 GC

- 不用标记压缩：需要加锁，影响并发性
- 不用分代：Go 中内存逃逸会将对象转移到堆中，大部分生命短的在栈中会随栈释放而释放，GC 没有优势

演进史：

- Go1.0 单协程垃圾回收
- Go1.1 多协程垃圾回收
- Go1.5 用户协程和垃圾回收并行， STW 降到 40ms
- Go1.6 STW 降到 5ms
- Go1.8 混合写屏障，STW 降到 0.5ms
