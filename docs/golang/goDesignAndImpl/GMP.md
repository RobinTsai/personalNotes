# GMP 模型

- G: 协程 Goroutine
- M: 系统级线程
- P: Go 的逻辑处理器（Process）

> Goroutine 有更快的上下文切换速度、更灵活的调度策略、可伸缩的栈空间管理。

## g0

- 每个线程有一个 g0 协程，g0 协程运行在线程栈上，作用是执行协程调度。每次调度时，都会切换到 g0，g0 再切换到其他 g。
- 协程切换的过程就是协程的上下文切换，切换前 g 会保存当前协程的执行现场（存在 g.gobuf 上，主要是几个重要的寄存器值）

## 线程本地存储

线程本地存储是线程本地（私有）可见的静态或全局内存。

线程本地存储将具体的操作系统线程和 m 结构体绑定在一起，因此 m 代表运行时的线程。在一个线程内，可以通过线程本地存储，获取到绑定的 g、结构体 m、处理器 P、以及 g0.

## 调度循环流程

调度循环是从 g0 开始，找到下一个要运行的协程 g，然后再从 g 切换到 g0 后开始新一轮调度。

- schedule 函数处理具体的调度策略，选择下一个要执行的 g
- execute 函数执行状态转移、g 与 m 之间的绑定操作
- gogo 与操作系统有关，用于完成栈的切换和 CPU 寄存器的恢复
- 然后 g 开始工作，直到触发调度（主动让渡或被动抢占）
- mcall 函数用于保存当前协程的执行现场，并切换到 g0
- 最后 g0 会根据切换原因执行不同的函数
- 从不同的函数最终再次调到 schedule 函数中去


## 调度策略

- P 中有一个 runnext 指针，指向的 goroutine 是最优先的（相比于本地队列、全局队列）
- P 中 runq 是本地队列，最多存储 256 个 g
- P 会优先选本地队列的 g，若为空，则选择全局队列的 g 来执行
- 为了避免全局队列的 g 一直不会被取到，P 会在每 61 次调度后会优先从全局队列中取 g 执行
- 若全局队列中也为空，则会去其他队列中窃取 g 执行
- 如果窃取不到，那么 P 会解除与 M 的绑定，回到空闲 P 队列中去；而 M 会进入休眠状态

这其中：

- 本地队列是个循环队列，256 元素的数组+头尾指针实现。
- 由于本地队列可能会有被窃取的情况，所以本地队列的访问是要加锁的
- 全局队列是一个链表，每个 P 都可以访问（共享），为了公平，每个 P 是平分了全局队列的 G 的
- P 每 61 次调度后访问全局队列，或本地队列中为空时，会访问全局队列
- P 每次访问全局队列会从全局队列中查找一批协程分配到本地队列中
- P 每次从全局队列中取的协程数量不会超过本地存储容量的一半，如果本地队列满了也会将本地队列的一半放回全局队列
- 协程窃取：
- 为了保证公平性，协程窃取不是按 P 的编号顺序取的，二是通过数学算法的顺序取（随机取一个比 P 个数小的质数，每加这个质数后对 8 取余，循环可依次循环取到 P id）
- 窃取会取 P 上一半的 G 放到自己的本地队列中

## 调度时机

- 主动让渡：是用 runtime.Gosched 或编译器在调用函数前插入代码。主动让渡后的 G 会放到全局队列中。
- 被动调度：是 G 在休眠、阻塞（channel 或 IO 阻塞）、垃圾回收而暂停时发起。它会在被唤醒时放到本地队列中去。
- 抢占调度：
  - 进程中会有另一个特殊的 G 叫监控线程，专门负责监控任务，它独立绑定一个 M，而不绑定 P
  - 监控线程每 10ms 会检测是否有就绪的网络协程，有的话会放到全局队列中
  - 监控线程会判断当前协程的执行时长过长（超过 10ms），或在发生系统调用（超过 20us），若是则会发生抢占（retake 函数）
  - Go 1.14 前抢占主要发生在函数调用处（安全检查点），弊端是 for 死循环会无法被抢占；因此之后版本中引入了信号抢占的机制
  - 信号是 SIGURG，信号机制会发生一次跳转到内核态，然后又跳回用户态（信号和注册函数在内核，执行注册函数在用户态）
- 系统调用前后 g 的执行
  - 系统调用前： 会保存 G 的执行环境，并解除 P 与 M 的绑定
  - 系统调用后： 会找 oldP 进行绑定，如果失败，会重新绑定一个空闲 P，如果没有空闲 P，则 G 放到全局队列中去
