# defer panic 和 recover

## defer

特性：

- 延迟执行，函数退出前执行
- 参数预计算，传入的参数表达式会在定义时立即取值
- LIFO 的执行顺序
- 返回值陷阱：将返回值先保存到栈上 -> 然后执行 defer 函数 -> 最后函数返回。
  - 其中最大的差别是 **函数返回变量** 是否在函数定义时初始化

演进：

- Go1.13 （不含）前 defer 都是在堆区分配，每次使用都涉及堆到栈的数据复制，性能较差
- Go1.13 做了将只有一个 defer 的语句放到了栈分配，但多次使用 defer 仍然是在堆
- Go1.14 做了编译内联优化，将 defer 转换为顺序函数，然后用位图的方式判断是否需要执行（defer 外的 if 条件）

分配：

- 存储：_defer 用链表的数据结果存储，新创建的 defer 结构会存放在链表的头部。
  - 存储是存储的 **协程** 级的所有 defer 函数，而不是仅仅当前函数中的
  - 由于函数调用是嵌套的，所以当前函数的 defer 肯定在链表头部，所以遍历找到 defer 结构不再是当前函数下的就可以停止了
- 分配：优先用 P 的局部缓存池，再用全局缓存池，然后是在堆区临时分配
- 调用：会将 defer 函数参数重新转移到栈中，调用后销毁本节点，然后将链表指向下一个节点

![go_defer](/assets/go_defer.png)

## panic 和 recover

- panic 的执行会遍历并调用 defer 链
- panic 也可以嵌套，但它的嵌套是在 defer 函数中嵌套
- 嵌套的 panic 也是用链表进行存储的，后来的 panic 放在链表头部，但它不会遍历 panic 链表执行（只遍历 defer 链）
- panic 执行 defer 的时候怎么找到编译器优化过的 defer 函数呢？（因为优化成顺序的了）
  - 会扫描栈帧，找到内联的 defer 函数帧，并构建成新的 _defer 结构存到链表头
- recover 的逻辑只是将 _panic.recovered 设置为 true
- panic 执行过程中发现 recovered==true 时最后会调用 mcall 切换到 g0 进行栈切换和恢复
