# Buffer Pool 缓存池

用于磁盘与 CPU 之间缓存，通过将磁盘中整个页数据加入到内存中缓存起来，进而降低 IO 开销。

通过配置可配置缓存池大小，默认 128M，最小 5M，配置小于 5M 也会是 5M.

```yaml
[server]
innodb_buffer_pool_size=268435456 # 总空间
innodb_buffer_pool_instatnces=2
```

## 内部组成

- 缓存页，从 磁盘 上 load 进来的页
- 控制块，和缓存页一一对应，记录了表空间、页号、缓冲页地址、链表节点信息等

由缓存页和控制块构成。控制块是连续的空间，缓存页也为连续的空间。每个控制块中有指针唯一的指向一个缓存页（一一对应）。

控制块会组成多个链表：

- free 链表（空闲页链表），每次 load 新页时从这里取一个空闲页装载。
- flush 链表（脏页链表），每对页数据修改后还没同步到磁盘前的数据页。
- LRU 链表，用于记录页的使用以及释放页以存储新数据页。
- 其他链表，如 unzip LRU 链表、zip clean 链表、zip free 链表

链表基节点（存放指向头节点、尾节点、节点长度等信息）不存放在 Buffer Pool 中，而在单独申请的内存空间。

## 如何寻找缓存页

通过 **表空间号 + 页号** 作为 key，**缓冲页控制块地址** 作为 value 会构建出一个 **哈希表**。

通过这个哈希表能快速找到这个控制块地址，从而找到页所在内存。当查某个表下数据时，B+ 树中存储了数据所在的页号信息。

（哈希表存储在哪里呢？）

## LRU 链表

简易版

- 访问页不在缓存池中，将缓存页放到 LRU 链表头位置
- 访问页已经在缓存池中，将缓存页放到 LRU 链头位置（记录最近使用了）
- 当空间不够时从**尾部淘汰**

问题：

> 预读，在执行请求时 mysql 会将查询数据后面或相关的页也加载到缓存中，包含线性预读和随机预读。预读的数据用的的吗？用不到会排挤 LRU 列表。

- 新加载的数据页不一定用到（预读）（是否使用问题）
- 加载的数据只用一次就不用了（全表扫描）（仅临时使用问题）

## LRU 链表划分区域

针对于“是否使用的问题”，mysql 的做法时按照某个比例将其分成两部分，young 区在前，old 区在后。先加到 old 区头部，再根据访问放到 young 区头部。

针对于 “仅临时使用问题”，那可否使用“频率计数”将其放到 young 区呢？不可以，这样有违 LRU 设计（不要问为什么，约定的），mysql 使用 “冷冻时间” （我自己起的名）解决。

- young 区，热数据，使用频率非常高，在 LRU 前半部
- old 区，冷数据，使用频率不高，在 LRU 后半部
- “冷冻时间”，记录第一次放入 old 区的时间，在一定时间间隔内重复访问不移动，超过这个时间后再访问就移动到 young 区头部

但还有一个问题：已经在 young 区头部的缓冲页在频繁被访问，会一直做“节点移动到头部”这件事，很浪费性能。mysql 优化：

- 访问 LRU 链表 young 区前 1/4 数据时，不进行节点移动，访问后方区域时移动。

> 据说还有很多优化内容，没有一一讲到。

## flush 链表的刷盘

后台有专用线程，每隔一段时间就把脏页刷新到磁盘中。刷新方式：

- 从 LRU 链表中冷数据中刷新一部分页面到磁盘（被称为 BUF_FLUSH_LRU 方式）
- 从 flush 链表中刷新一部分页面到磁盘（BUF_FLUSH_LIST）

还有一种方式是在 free 链表已经没有空间时，那么不得不

- 从 LRU 尾部取到一个页，为脏页则刷盘（严重低效）（BUF_FLUSH_SINGLE_PAGE）

> flush 的刷盘还有很多考虑，后面待在其他地方补充

## Buffer Pool 的多实例

因为在访问 Buffer Pool 中的各个链表时，都是需要加锁的，防止并发冲突。所以只有一个实例肯定效率不高。

Buffer Pool 在内存中是由若干个小实例组成的。可以通过 `innodb_buffer_pool_instatnces` 来控制个数。

```
每个实例的大小 = innodb_buffer_pool_size / innodb_buffer_pool_instatnces
```

## Buffer Pool Chunk

在 5.7.5 版本之后，允许在 runtime 过程中调整 Buffer Pool 大小，但此操作需要先申请内存然后将旧空间中内容复制到新空间——极其耗时。因此将 Buffer Pool 分块了。

即，一个 Buffer Pool 由多个 chunk 组成，每一个 chunk 是一块连续的内存空间，里面包含了若干个 控制块和缓冲页。

配置项 `innodb_buffer_pool_chunk_size` 用以控制每个 chunk 的大小。（他们之间有倍数关系，如果配置不符也会保证倍数关系，这里就不说了，用到了后查询资料吧）