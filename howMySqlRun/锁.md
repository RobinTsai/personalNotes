# 锁

## 锁和MVCC

- 写-写的情况只用到了锁
- 写-读的情况，有两种方案：
    - 写使用锁，读使用 MVCC
    - 写使用锁，读也使用锁
- 读-读的情况不需要控制

> 写-读情况中对于“读”的两种方案怎么选择呢？
>
> 当操作中需要 读 和 写 是像写和写一样相互冲突的处理时，则需要用锁控制。如在一个事务中，读出来内容后需要保证到提交之前都不能有其他写参与，则用读锁控制。如银行存款，读出来，加上固定值，再提交，读出后提交前不允许写。

利用 MVCC 实现读就是 **一致性读**；利用 锁 实现读就是 **锁定读**。

### 锁的简单工作流程

所有写操作都会先加锁，加锁的过程是先在内存中生成一个锁结构，然后此锁和需要修改的记录进行绑定。

如果绑定的时候发现记录上已经绑定了锁，就将此锁的 is_waiting 字段设置为 true。

当一个锁释放时，会检测一下当前记录是否还有关联的其它锁等待与其绑定，如果有，则将其 is_waiting 设置为 false，然后把对应事务唤醒。

## 锁定读

- 共享锁（Shared Lock），又叫 S 锁
- 独占锁（Exclusive Lock），又叫排他锁，X 锁

命令 

```sql
SELECT ... LOCK IN SHARE MODE; -- 加 共享锁
SELECT ... FOR UPDATE; -- 加 独占锁
```

## 写操作锁

根据写操作不同，使用锁也不同

- DELETE 操作会在查到后上 X 锁，然后执行 delete mark 操作
- UPDATE 操作有三种情况
    - 如果修改前后**存储空间完全不变**，则加 X 锁后修改
    - 如果修改前后至少有一个列占用的空间发生了变化，则会先加 X 锁，然后将原记录*彻底删除*，最后再插入一条新记录
- INSERT 操作会收到 隐式锁 的保护

> “彻底删除”是指移动到垃圾链表中（见 undo 日志一章）。


## 多粒度锁

表锁、行锁，不展开了。

表锁的粒度更粗，但占用资源少，因为锁了整张表，所以性能差。

## InnoDB 中的锁（重头戏）

### InnoDB 中表锁

InnoDB 中表锁有：

- 共享锁（S 锁）
- 独占锁（X 锁）
- 意向共享锁（IS 锁）
- 意向独占锁（IX 锁）
- AUTO-INC 锁，保证自增键时用到了，插入结束后释放
- 轻量级锁，也在自增键的地方用到，在生成自增键的列后释放

> IS 锁和 IX 锁
>
> 他们是用来快速判断表内是否有行级 S 锁和 X 锁的，用来避免遍历判断。当表内有行使用了 S 锁或 X 锁，就会在表上对应的添加 IS 锁和 IX 锁。这两个锁相互兼容。只是 IS 和 X 不兼容，IX 和 S 不兼容。

> AUTO-INC 锁和轻量级锁
>
> 他们都在自增列中用到，因为自增序列是在表级下的，所以都是表级别锁。
> 由上介绍可见，轻量级锁在生成对应的自增值后就释放，所以比 AUTO-INC 锁会更轻量。
> 使用轻量级锁的场景是**当插入的记录数量是固定的**时采用，**批量插入**时就会用AUTO-INC 锁。
> InnoDB 中通过配置项 `innodb_autoinc_lock_mode` 控制使用哪种自增锁：
> ```
> 0：一律采用 AUTO-INC 锁
> 1：采用轻量级锁 + AUTO-INC 锁
> 2：一律采用轻量级锁
> ```
> 不过，在主从复制场景下，使用 2 配置是不安全的。

表锁的命令

```SQL
LOCK TABLES table READ;  -- S 锁
LOCK TABLES table WRITE; -- X 锁
```

### InnoDB 中行锁

InnoDB 中行锁有

- Record Lock，又叫记录锁，分有 S 锁、X 锁，用在正常记录上
- Gap Lock，锁 gap 用的，解决幻读问题
- Next-Key 锁，是一个 Gap 锁 后面加上 一个正常记录锁组成。
- Insert Intent 锁，插入意向锁，是 gap 锁的等待者，只做等待着，不阻塞其他“人”。
- 隐式锁，是用事务 ID 实现的“不冲突则无锁，冲突就有锁”的锁，延时生成锁结构。


命令

```sql
SELECT ... LOCK IN SHARE MODE; -- 加 共享锁
SELECT ... FOR UPDATE; -- 加 独占锁
UPDATE ...
DELETE ...
```

#### 隐式锁的场景和过程

场景：如在一个事务中，先插入一条记录，然后尚未提交时有其他事务准备读这条记录，如果能读到就称为了脏读，如果还要写就出现脏写，所以要避免，即用了隐式锁。

实现：聚簇索引用 trx_id 实现，二级索引用 页中存储的最大事务 ID 实现。如果检测到记录的 trx_id 是活跃状态，即正在插入且事务还未提交，则由检测者创建一个 X 锁结构并与插入行相关联，而自己创建一个 is_waiting: true 状态的锁结构进入等待状态。


## 死锁

当 A 事务上锁了 a 记录，然后再去上锁 b 记录；而 B 事务上锁了 b 记录然后再区上锁 a 记录时，就发生了死锁。（此条记录可以通过按固定顺序访问 a、b 记录来避免。）

如果发生死锁，InnoDB 会选择一个较小的事务进行回滚（它有检测机制），并向客户端发送一条消息。较小的事务是指在事务执行过程中插入、更新或删除记录条数较少的事务。

运维技巧：

通过命令 `SHOW ENGINE INNODB STATUS` 查看最近一条死锁信息；通过全局变量 `innodb_print_all_deadlocks ON` 开启所有死锁日志记录。

## 加锁分析

略，比较复杂，后期再整理。

加锁要考虑的因素很多，
- 事务的隔离级别
- 执行的索引类型（聚簇索引、唯一二级索引、普通二级索引）
- 是否为精确匹配
- 是否是唯一性搜索（聚簇索引等式查询、唯一二级非null等式查询、联合唯一索引等式查询）

半一致性读

在 Update 操作时，某行已经上锁了，但本事务不确定它是否符合自己的查询条件，所以先 check 它，若不符合则不上锁，若符合则阻塞在此锁上。

索引下推

搜索条件下推到存储引擎中区判断，而不是返回到 server 层再判断。