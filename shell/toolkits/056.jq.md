- [jq](#jq)
  - [Filter 过滤表达式](#filter-过滤表达式)
  - [内置函数](#内置函数)
    - [搜索类函数](#搜索类函数)
    - [逻辑判断函数（返回 bool 的函数）](#逻辑判断函数返回-bool-的函数)
    - [日期相关函数](#日期相关函数)
    - [字符串相关函数](#字符串相关函数)
    - [数组相关函数](#数组相关函数)
    - [Math 相关函数](#math-相关函数)
    - [条件、循环和迭代](#条件循环和迭代)
  - [字符串格式化或转义](#字符串格式化或转义)
  - [正则表达式](#正则表达式)
  - [高级特性](#高级特性)
    - [使用变量/符号绑定运算符](#使用变量符号绑定运算符)
    - [解构操作](#解构操作)
    - [定义函数](#定义函数)
    - [作用域](#作用域)
    - [Reduce](#reduce)
    - [递归](#递归)
    - [生成器和迭代器](#生成器和迭代器)
  - [IO 操作](#io-操作)
  - [流式](#流式)
  - [赋值](#赋值)
  - [模块](#模块)
  - [颜色控制](#颜色控制)


# jq

```sh
jq -r '.[] | select(.name == "foo") | .id'
```

- `-r`: 以 raw 文本输出，而不是带引号的 json 文本输出。
- `.str` 取名为 str 的属性的值
- 改变原值要用 `|= express`
- 如果 jq 之后使用 linux pipe 有无法输出的问题，尝试使用 `| stdbuf -oL jq xxx`。stdbuf 可变更标准流的缓冲区。

## Filter 过滤表达式

- 字符串的输入要有引号，否则被认为是对象
- 取不到属性时，返回 null
- 基本使用 `jq '.foo'` 然后在交互页面输入 `{"foo": "bar"}`，会输出显示 `"bar"`

| 表达式                              | 意义                                                     | 示例                                                                           | 输入 | 输出 |
| ----------------------------------- | -------------------------------------------------------- | ------------------------------------------------------------------------------ | ---- | ---- |
| `.`                                 | 取输入本身                                               |                                                                                |
| `.ATTR` 或 `."ATTR"` 或 `.["ATTR"]` | 取属性 ATTR 的值（含特殊符号用后两者）                   |                                                                                |      |
| `.ATTR1.ATTR2`                      | 级联地取属性 `Obj.ATTR1.ATTR2` 的值                      |
| `.ATTR1\|.ATTR2`                    | 等同于 `.ATTR1.ATTR2`                                    |
|                                     |
| `.[N]`（N为整数）                   | 取数组下标 N 的元素，若为负数从后数                      | `jq '.[-2]'` 表示取倒数第二个元素                                              |
| `.[N1:N2]`                          | 取数组下标 [N1,N2) 的元素                                |                                                                                |
| `.[:N2]`                            | 取数组下标 [0,N2) 的元素                                 |                                                                                |
| `.[N1:]`                            | 取数组下标 [N1, END] 的元素                              |                                                                                |
| `.[]`                               | 返回所有元素，如果是对象以序返回所有值；也可用于构造数组 |                                                                                |
|                                     |
| `.foo, .bar`                        | 返回 foo 和 bar 的值（换行分隔）                         |                                                                                |
| `\|`                                | 管道，将上一个输出作为下一个输入                         |                                                                                |      |      |
| `.[] \| .name`                      | 取数组所有元素，再取元素中 name 属性的值                 |
|                                     |
| `()`                                | 括号，和算式的括号作用一致，可以于加法乘法等             | `(. + 2) * 5`，假设 `.` 取到数值 `a`，返回 `(a+2)*5`                           |
|                                     |
| `[ 表达式 ]`                        | 构造数组                                                 | `jq '[.user, .projects[]]'` 将 user 和 projects 数组中的元素合并成一个数组返回 |
|                                     |                                                          | `jq '[ .[] \| . * 2]'` 将数组中所有元素乘以 2 后构造一个新数组返回             |
| `{ 表达式 }`                        | 构造对象                                                 | `jq '{ "Name": .name, "Age": .age }'` 将 name 和 age 属性改名返回              |
|                                     |                                                          | `jq '{name, Age: .age }'` name 复用原属性名                                    |
| `{ .ATTR[] }`                       | 将 ATTR 数组元素散列构造对象                             | `jq '{name, title: .titles[] }'` 将 titles 数组展开依次返回构造对象            |      |
|                                     |                                                          | `{(.user): .titles}` 将 user 属性作为 key，titles 属性作为 value               |
| `..`                                | 递归下降，处理每一个 value；等同于                       |

内置操作符和函数

| 操作符          | 意义                                               |
| --------------- | -------------------------------------------------- |
| `+`,`-`,`*`,`/` | 用于数值运算                                       |
| `+`             | 用于字符串表示拼接                                 |
| `-`             | 用于数组中使用表示排除                             | `jq '. - ["xml", "yaml"]'` 结果中除了 xml 和 yaml 外其他值都保留 |
| `/`             | 后跟 string 表示用 string 作为分割字符串，返回数组 |
| `*`             | str * number 表示重复字符串 number 次              |
|                 | obj * obj 表示两个对象合并（嵌套地）               |

## 内置函数


| 函数                                                | 意义                                                                        | 示例                       |
| --------------------------------------------------- | --------------------------------------------------------------------------- | -------------------------- |
| `length`                                            | 取字符串、数组、对象的长度                                                  | `jq 'length'`              |
| `utf8bytelength`                                    | 取字符串的字节长度，一个中文算3个字节                                       |
| `keys`, `keys_unsorted`                             | 返回对象的键名（前者排序），数组返回下标                                    |
| `path(path_expression)`                             | 输出数组表示元素定位的路径                                                  |
| `del(path_expression)`                              | 从对象或数组中**删除**对应元素                                              |
| `getpath(PATHS)`                                    | 按给定的 path 获取元素值                                                    |
| `setpath(PATHS; VALUE)`                             | 按给定 path 设置元素值                                                      |
| `delpaths(PATHS)`                                   | 按给定 path 删除元素                                                        |
| `to_entries, from_entries`                          | `{"k": "v"}` 和 `{"key": key, "value": v}`（entries） 相互转化              |
| `with_entries`                                      |                                                                             |
| `select(boolean_expression)`                        | 按 `bool_expression` 筛选元素进行保留，常与 map 合用                        | `jq 'map(select(. >= 2))'` |
| `arrays, objects, iterables, booleans, numbers`     | 内置用于 `select` 筛选保留的类型，即按类型进行保留（1）                     |
| `normals, finites, strings, nulls, values, scalars` | 内置用于 `select` 筛选保留的类型，即按类型进行保留（2）                     |
|                                                     | iterables (arrays or objects), normals (normal numbers)                     |
|                                                     | finites (finite numbers), values (non-null values), scalars (non-iterables) |
| `empty`                                             | 什么也不返回，什么也不，null 也不                                           |
| `error(message)`                                    | 返回一个 error，error 可以被 try/catch 捕获                                 |
| `halt`                                              | 停止 jq 程序，不再执行，退出码 0                                            |
| `halt_error, halt_error(exit_code)`                 | 停止 jq 程序并输出 error 或返回 exit_code (default 5)                       |
| `type`                                              | 返回参数类型 `null, boolean, number, string, array, object`                 |
| `explode`                                           | 转换 str 为 ASCII 码值                                                      |
| `implode`                                           | 转换 ASCII 码数值列表为 str                                                 |
| `ascii_downcase, ascii_upcase`                      | 转换大小写                                                                  |

### 搜索类函数

| 函数                  | 意义                                                                           | 示例 |
| --------------------- | ------------------------------------------------------------------------------ | ---- |
| `indices(sub)`        | 查找子集(子串、数组序列、数组元素)，以数组方式返回下标位置（查到多个返回多个） |
| `index(s), rindex(s)` | 查找首个/末个子集 s，返回下标位置（仅一个返回）                                |

### 逻辑判断函数（返回 bool 的函数）

| 函数                                             | 意义                                               | 示例                   |
| ------------------------------------------------ | -------------------------------------------------- | ---------------------- |
| `any, any(condition), any(generator; condition)` | 逻辑或，输入 bool 类型的数组，返回 或 的逻辑表达式 |
| `all, all(condition), all(generator; condition)` | 逻辑与                                             |
| `has(key)`                                       | 对象或数组返回是否存在 key/元素，返回 bool 值      | `jq 'map(has("foo"))'` |
| `in(obj 或 arr)`                                 | 判断 key 是否存在于 obj 或 arr 中，返回 bool 值    |
| `inside(value)`                                  | 判断输入是否是 value 的子集或子字符串              |
| `contains(element)`                              | 判断输入是否完整包含 element，与 `inside` 相反     |
| `==, !=`                                         |                                                    |



### 日期相关函数

| 函数                                                                        | 意义                                                                             | 示例                                     |
| --------------------------------------------------------------------------- | -------------------------------------------------------------------------------- | ---------------------------------------- |
| `fromdate`                                                                  | 解析输入日期，输出时间戳，只支持 ISO8601 格式                                    |
| `todate`                                                                    | 与 `fromdate` 相反                                                               |
| `gmtime`                                                                    | 将时间戳转换 GMT，输出 年，月（0-based），日，小时，分钟，秒，星期，本年中第几天 |
| `localtime`                                                                 | 类似于 `gmtime`，但会考虑时区                                                    |
| `strptime("%Y-%m-%dT%H:%M:%SZ")`                                            | 按指定格式解析输入的日期字符串，输出 `gmtime`                                    |
| `now`                                                                       | 返回当前时间戳                                                                   |
| `mktime`                                                                    | 将 `gmtime` 转换为时间戳                                                         | `strptime("%Y-%m-%dT%H:%M:%SZ")\|mktime` |
| = C 中的 `strptime, strftime, strflocaltime, mktime, gmtime, and localtime` |

### 字符串相关函数

| 函数                            | 意义                                                                               | 示例                                          |
| ------------------------------- | ---------------------------------------------------------------------------------- | --------------------------------------------- |
| `tostring`                      | JSON-encoded 输出                                                                  | `jq '.[] \| tostring'` 将数组元素转换成字符串 |
| `startswith(str),endswith(str)` | 是否以 str 开头或结尾                                                              |
| `ltrimstr(str), rtrimstr(str)`  | 去掉开头或结尾的 str                                                               |
| `split(str)`                    | 按 str 分割字符串                                                                  |
| `join(str)`                     | 用 str 拼接数组（数值或 bool 会转换成字符串，null 认为空字符串，数组或对象不支持） |
| `tostring, tojson, fromjson`    | 输出未 encode 的 json，输出 encode 后的 json（内部引号转义），解析为 json          | `jq '.age \|= tostring'`                      |
|                                 |                                                                                    | `jq '.age \|= tostring'`                      |
| `\(exp)`                        | 字符串注入，类似于 Go 的 "xxx is %s"，支持表达式                                   | `jq '"\(.) + 1 = \(.+1)"'`                    |

### 数组相关函数

| 函数                          | 意义                                                                   | 示例 |
| ----------------------------- | ---------------------------------------------------------------------- | ---- |
| `flatten, flatten(depth)`     | 输入数组（嵌套的），扁平化返回数组（一维，或 depth 维）                |
| `reverse`                     | 翻转数组                                                               |
| `combinations`                | 输入数组，输出所有组合，可选 n 个元素                                  |
| `combinations(n)`             | 输出 0-n 间所有数字可能的组合                                          |
| `add`                         | 输入数组，返回数组元素的 `+`，按类型是数字相加、字符串拼接、对象合并等 |
| `sort, sort_by(path_exp)`     | 排序和指定 key 排序，输入必须是数组                                    |
|                               | `null < false < true < numbers < strings < arrays < objects`           |
|                               | objects 的排序：先比较 key，然后比较 value                             |
| `group_by(path_exp)`          | 输入数组，按 path_exp 有相同的 value 进行分组，返回排序后端二维数组    |
| `unique, unique_by(path_exp)` | (按 path_exp) 去重，返回去重后的数组                                   |

### Math 相关函数

| 函数                                    | 意义                                                | 示例       |
| --------------------------------------- | --------------------------------------------------- | ---------- |
| `floor`                                 | 向下取整                                            | jq 'floor' |
| `sqrt`                                  | 开方                                                |
| `tonumber`                              | 将输入（数值或字符串）转换为数值                    |
| `infinite, nan`                         | 生成 无穷大、非数值（这两种 number type）           |
| `isinfinite, isnan, isfinite, isnormal` | 判断是否 无穷大、非数值、有穷数、正常数             |
| `min, max`                              | 返回数组中最小/大值                                 |
| `min_by(path_exp), max_by(path_exp)`    | 按对象数组中 `path_exp` 指定对象的数值返回最小/大值 |
| C math functions                        | 支持众多 C 库数学函数                               |

---

   `$__loc__`
       Produces an object with a "file" key and a "line" key, with the filename and line number where $__loc__ occurs, as values.

           jq 'try error("\($__loc__)") catch .'
              null
           => "{\"file\":\"<top-level>\",\"line\":1}"

   paths, paths(node_filter), leaf_paths
       paths outputs the paths to all the elements in its input (except it does not output the empty list, representing . itself).

       paths(f) outputs the paths to any values for which f is true. That is, paths(numbers) outputs the paths to all numeric values.

       leaf_paths is an alias of paths(scalars); leaf_paths is deprecated and will be removed in the next major release.

           jq '[paths]'
              [1,[[],{"a":2}]]
           => [[0],[1],[1,0],[1,1],[1,1,"a"]]

           jq '[paths(scalars)]'
              [1,[[],{"a":2}]]
           => [[0],[1,1,"a"]]

### 条件、循环和迭代

大部分循环迭代不会消耗额外的内存。

| 函数                                                | 意义                                                                                   | 示例                                                                  |
| :-------------------------------------------------- | :------------------------------------------------------------------------------------- | :-------------------------------------------------------------------- |
| `map(表达式)`                                       | for each 数组元素，等价于 `[.[] \| 表达式]`                                            | `jq 'map(.+1)'`, [1,2,3] => [2,3,4]                                   |
| `map_values(表达式)`                                | for each 对象元素的值，等价于 `.[] \| 表达式`                                          | `jq 'map_values(.+1)'` 所有 value 加 1                                |
| `range(upto), range(from;upto) range(from;upto;by)` | 生成序列                                                                               |                                                                       |
| `while(cond_exp; update_exp)`                       | 重复应用 update_exp 直到 cond_exp 为 false                                             | `jq '[while(.<100; .*2)]'`                                            |
| `until(cond_exp; next_exp)`                         | 将输入重复应用 next_exp 直到 cond_exp 为 true                                          | `jq '[.,1]\|until(.[0] < 1; [.[0] - 1, .[1] * .[0]])\|.[1]'`，4 => 24 |
| `recurse(filter_exp; cond)`                         | **递归**地应用 filter_exp（输出再次执行 filter_exp），返回所有结果，直到 cond 为 false |
| `recurse(filter_exp)`                               | == `recurse(f; . != null)`                                                             |
| `recurse`                                           | == `recurse(.[]?)` == 保留所有                                                         |
| `recurse_down`                                      |
| `walk(f)`                                           | 递归地对每个元素执行 f                                                                 | `jq 'walk(if type == "array" then sort else . end)'`                  |
| `$ENV, env`                                         | 环境变量对象，`$ENV.ATTR` 取值。这里输入任意                                           |
| `transpose`                                         | 将数组转置，若对应位置元素不存在则填充 null                                            |
| `bsearch(x)`                                        | 在**排序数组**中二分查找 x，返回索引或插入位置（输入必须排序）                         |
| `if EXP then EXP elif EXP else EXP end`             |
| `>, >=, <=, <`                                      |
| `and/or/not`                                        | 如果操作符两边为多个值，则每个值运算一次                                               | `jq '(true, true) and (true, false)'` => true, false, true, false`    |
| `a // b`                                            | 可选操作符，== `if a then a else b end`                                                |
| `try EXP catch EXP`                                 | catch 可省略，相当于 `catch empty`；当 try 获取 error 后，errMsg 会传给 catch          |
|                                                     |                                                                                        | `try repeat(exp) catch .=="break" then empty else error;`             |
| `label $out \| ... break $out ...`                  |                                                                                        |                                                                       |
| `EXP?`                                              | == `try EXP`，有则取值，无返回 null，error 会跳过                                      |

## 字符串格式化或转义

       The @foo syntax is used to format and escape strings, which is useful for building URLs, documents in a language like HTML or XML, and so forth. @foo can be used as a filter on its own, the possible escapings are:

       @text:

       @json:

       @html:

       @uri:

       @csv:

       @tsv:

       @sh:

       @base64:

       @base64d:

       This  syntax can be combined with string interpolation in a useful way. You can follow a @foo token with a string literal. The contents of the string literal will not be escaped. However, all interpolations made inside that
       string literal will be escaped. For instance,

           @uri "https://www.google.com/search?q=\(.search)"

       will produce the following output for the input {"search":"what is jq?"}:

           "https://www.google.com/search?q=what%20is%20jq%3F"

       Note that the slashes, question mark, etc. in the URL are not escaped, as they were part of the string literal.

           jq '@html'
              "This works if x < y"
           => "This works if x &lt; y"

           jq '@sh "echo \(.)"'
              "O'Hara's Ale"
           => "echo 'O'\\''Hara'\\''s Ale'"

           jq '@base64'
              "This is a message"
           => "VGhpcyBpcyBhIG1lc3NhZ2U="

           jq '@base64d'
              "VGhpcyBpcyBhIG1lc3NhZ2U="
           => "This is a message"

## 正则表达式

       jq uses the Oniguruma regular expression library, as do php, ruby, TextMate, Sublime Text, etc, so the description here will focus on jq specifics.

       The jq regex filters are defined so that they can be used using one of these patterns:

           STRING | FILTER( REGEX )
           STRING | FILTER( REGEX; FLAGS )
           STRING | FILTER( [REGEX] )
           STRING | FILTER( [REGEX, FLAGS] )

       where: * STRING, REGEX and FLAGS are jq strings and subject to jq string interpolation; * REGEX, after string interpolation, should be a valid PCRE regex; * FILTER  is  one  of
       test, match, or capture, as described below.

       FLAGS is a string consisting of one of more of the supported flags:

       ○   g - Global search (find all matches, not just the first)

       ○   i - Case insensitive search

       ○   m - Multi line mode ('.' will match newlines)

       ○   n - Ignore empty matches

       ○   p - Both s and m modes are enabled

       ○   s - Single line mode ('^' -> '\A', '$' -> '\Z')

       ○   l - Find longest possible matches

       ○   x - Extended regex format (ignore whitespace and comments)

       To match whitespace in an x pattern use an escape such as \s, e.g.

       ○   test( "a\sb", "x" ).

       Note that certain flags may also be specified within REGEX, e.g.

       ○

       evaluates to: true, true, false, false.

   test(val), test(regex; flags)
       Like match, but does not return match objects, only true or false for whether or not the regex matches the input.

           jq 'test("foo")'
              "foo"
           => true

           jq '.[] | test("a b c # spaces are ignored"; "ix")'
              ["xabcd", "ABC"]
           => true, true

   match(val), match(regex; flags)
       match outputs an object for each match it finds. Matches have the following fields:

       ○   offset - offset in UTF-8 codepoints from the beginning of the input

       ○   length - length in UTF-8 codepoints of the match

       ○   string - the string that it matched

       ○   captures - an array of objects representing capturing groups.

       Capturing group objects have the following fields:

       ○   offset - offset in UTF-8 codepoints from the beginning of the input

       ○   length - length in UTF-8 codepoints of this capturing group

       ○   string - the string that was captured

       ○   name - the name of the capturing group (or null if it was unnamed)

       Capturing groups that did not match anything return an offset of -1

           jq 'match("(abc)+"; "g")'
              "abc abc"
           => {"offset": 0, "length": 3, "string": "abc", "captures": [{"offset": 0, "length": 3, "string": "abc", "name": null}]}, {"offset": 4, "length": 3, "string": "abc", "captures": [{"offset": 4, "length": 3, "string": "abc", "name": null}]}

           jq 'match("foo")'
              "foo bar foo"
           => {"offset": 0, "length": 3, "string": "foo", "captures": []}

           jq 'match(["foo", "ig"])'
              "foo bar FOO"
           => {"offset": 0, "length": 3, "string": "foo", "captures": []}, {"offset": 8, "length": 3, "string": "FOO", "captures": []}

           jq 'match("foo (?<bar123>bar)? foo"; "ig")'
              "foo bar foo foo  foo"
           => {"offset": 0, "length": 11, "string": "foo bar foo", "captures": [{"offset": 4, "length": 3, "string": "bar", "name": "bar123"}]}, {"offset": 12, "length": 8, "string": "foo  foo", "captures": [{"offset": -1, "length": 0, "string": null, "name": "bar123"}]}

           jq '[ match("."; "g")] | length'
              "abc"
           => 3

   capture(val), capture(regex; flags)
       Collects the named captures in a JSON object, with the name of each capture as the key, and the matched string as the corresponding value.

           jq 'capture("(?<a>[a-z]+)-(?<n>[0-9]+)")'
              "xyzzy-14"
           => { "a": "xyzzy", "n": "14" }

   scan(regex), scan(regex; flags)
       Emit  a stream of the non-overlapping substrings of the input that match the regex in accordance with the flags, if any have been specified. If there is no match, the stream is
       empty. To capture all the matches for each input string, use the idiom [ expr ], e.g. [ scan(regex) ].

   split(regex; flags)
       For backwards compatibility, split splits on a string, not a regex.

   splits(regex), splits(regex; flags)
       These provide the same results as their split counterparts, but as a stream instead of an array.

   sub(regex; tostring) sub(regex; string; flags)
       Emit the string obtained by replacing the first match of regex in the input string with tostring, after interpolation. tostring should be a jq string, and  may  contain  refer‐
       ences  to named captures. The named captures are, in effect, presented as a JSON object (as constructed by capture) to tostring, so a reference to a captured variable named "x"
       would take the form: "(.x)".

   gsub(regex; string), gsub(regex; string; flags)
       gsub is like sub but all the non-overlapping occurrences of the regex are replaced by the string, after interpolation.

## 高级特性

ADVANCED FEATURES
       Variables are an absolute necessity in most programming languages, but they're relegated to an "advanced feature" in jq.

       In most languages, variables are the only means of passing around data. If you calculate a value, and you want to use it more than once, you'll need to store it in a  variable.
       To  pass  a  value  to  another part of the program, you'll need that part of the program to define a variable (as a function parameter, object member, or whatever) in which to
       place the data.

       It is also possible to define functions in jq, although this is is a feature whose biggest use is defining jq's standard library (many jq functions such as map and find are  in
       fact written in jq).

       jq has reduction operators, which are very powerful but a bit tricky. Again, these are mostly used internally, to define some useful bits of jq's standard library.

       It may not be obvious at first, but jq is all about generators (yes, as often found in other languages). Some utilities are provided to help deal with generators.

       Some minimal I/O support (besides reading JSON from standard input, and writing JSON to standard output) is available.

       Finally, there is a module/library system.

### 使用变量/符号绑定运算符

   Variable / Symbolic Binding Operator: ... as $identifier | ...
       In  jq,  all filters have an input and an output, so manual plumbing is not necessary to pass a value from one part of a program to the next. Many expressions, for instance a +
       b, pass their input to two distinct subexpressions (here a and b are both passed the same input), so variables aren't usually necessary in order to use a value twice.

       For instance, calculating the average value of an array of numbers requires a few variables in most languages - at least one to hold the array, perhaps one for each element  or
       for  a loop counter. In jq, it's simply add / length - the add expression is given the array and produces its sum, and the length expression is given the array and produces its
       length.

       So, there's generally a cleaner way to solve most problems in jq than defining variables. Still, sometimes they do make things easier, so jq lets you define variables using ex‐
       pression as $variable. All variable names start with $. Here's a slightly uglier version of the array-averaging example:

           length as $array_length | add / $array_length

       We'll need a more complicated problem to find a situation where using variables actually makes our lives easier.

       Suppose we have an array of blog posts, with "author" and "title" fields, and another object which is used to map author usernames to real names. Our input looks like:

           {"posts": [{"title": "Frist psot", "author": "anon"},
                      {"title": "A well-written article", "author": "person1"}],
            "realnames": {"anon": "Anonymous Coward",
                          "person1": "Person McPherson"}}

       We want to produce the posts with the author field containing a real name, as in:

           {"title": "Frist psot", "author": "Anonymous Coward"}
           {"title": "A well-written article", "author": "Person McPherson"}

       We use a variable, $names, to store the realnames object, so that we can refer to it later when looking up author usernames:

           .realnames as $names | .posts[] | {title, author: $names[.author]}

       The  expression  exp  as  $x  | ... means: for each value of expression exp, run the rest of the pipeline with the entire original input, and with $x set to that value. Thus as
       functions as something of a foreach loop.

       Just as {foo} is a handy way of writing {foo: .foo}, so {$foo} is a handy way of writing {foo:$foo}.

       Multiple variables may be declared using a single as expression by providing a pattern that matches the structure of the input (this is known as "destructuring"):

           . as {realnames: $names, posts: [$first, $second]} | ...

       The variable declarations in array patterns (e.g., . as [$first, $second]) bind to the elements of the array in from the element at index zero on up, in order. When there is no
       value at the index for an array pattern element, null is bound to that variable.

       Variables are scoped over the rest of the expression that defines them, so

           .realnames as $names | (.posts[] | {title, author: $names[.author]})

       will work, but

           (.realnames as $names | .posts[]) | {title, author: $names[.author]}

       won't.

       For  programming  language  theorists, it's more accurate to say that jq variables are lexically-scoped bindings. In particular there's no way to change the value of a binding;
       one can only setup a new binding with the same name, but which will not be visible where the old one was.

           jq '.bar as $x | .foo | . + $x'
              {"foo":10, "bar":200}
           => 210

           jq '. as $i|[(.*2|. as $i| $i), $i]'
              5
           => [10,5]

           jq '. as [$a, $b, {c: $c}] | $a + $b + $c'
              [2, 3, {"c": 4, "d": 5}]
           => 9

           jq '.[] as [$a, $b] | {a: $a, b: $b}'
              [[0], [0, 1], [2, 1, 0]]
           => {"a":0,"b":null}, {"a":0,"b":1}, {"a":2,"b":1}

### 解构操作

   Destructuring Alternative Operator: ?//

       The destructuring alternative operator provides a concise mechanism for destructuring an input that can take one of several forms.

       Suppose we have an API that returns a list of resources and events associated with them, and we want to get the user_id and timestamp of the first event for each resource.  The
       API (having been clumsily converted from XML) will only wrap the events in an array if the resource has multiple events:

           {"resources": [{"id": 1, "kind": "widget", "events": {"action": "create", "user_id": 1, "ts": 13}},
                          {"id": 2, "kind": "widget", "events": [{"action": "create", "user_id": 1, "ts": 14}, {"action": "destroy", "user_id": 1, "ts": 15}]}]}

       We can use the destructuring alternative operator to handle this structural change simply:

           .resources[] as {$id, $kind, events: {$user_id, $ts}} ?// {$id, $kind, events: [{$user_id, $ts}]} | {$user_id, $kind, $id, $ts}

       Or, if we aren't sure if the input is an array of values or an object:

           .[] as [$id, $kind, $user_id, $ts] ?// {$id, $kind, $user_id, $ts} | ...

       Each  alternative  need  not  define all of the same variables, but all named variables will be available to the subsequent expression. Variables not matched in the alternative
       that succeeded will be null:

           .resources[] as {$id, $kind, events: {$user_id, $ts}} ?// {$id, $kind, events: [{$first_user_id, $first_ts}]} | {$user_id, $first_user_id, $kind, $id, $ts, $first_ts}

       Additionally, if the subsequent expression returns an error, the alternative operator will attempt to try the next binding. Errors that occur during the final  alternative  are
       passed through.

           [[3]] | .[] as [$a] ?// [$b] | if $a != null then error("err: \($a)") else {$a,$b} end

           jq '.[] as {$a, $b, c: {$d, $e}} ?// {$a, $b, c: [{$d, $e}]} | {$a, $b, $d, $e}'
              [{"a": 1, "b": 2, "c": {"d": 3, "e": 4}}, {"a": 1, "b": 2, "c": [{"d": 3, "e": 4}]}]
           => {"a":1,"b":2,"d":3,"e":4}, {"a":1,"b":2,"d":3,"e":4}

           jq '.[] as {$a, $b, c: {$d}} ?// {$a, $b, c: [{$e}]} | {$a, $b, $d, $e}'
              [{"a": 1, "b": 2, "c": {"d": 3, "e": 4}}, {"a": 1, "b": 2, "c": [{"d": 3, "e": 4}]}]
           => {"a":1,"b":2,"d":3,"e":null}, {"a":1,"b":2,"d":null,"e":4}

           jq '.[] as [$a] ?// [$b] | if $a != null then error("err: \($a)") else {$a,$b} end'
              [[3]]
           => {"a":null,"b":3}

### 定义函数

   Defining Functions
       You can give a filter a name using "def" syntax:

           def increment: . + 1;

       From then on, increment is usable as a filter just like a builtin function (in fact, this is how many of the builtins are defined). A function may take arguments:

           def map(f): [.[] | f];

       Arguments  are  passed as filters (functions with no arguments), not as values. The same argument may be referenced multiple times with different inputs (here f is run for each
       element of the input array). Arguments to a function work more like callbacks than like value arguments. This is important to understand. Consider:

           def foo(f): f|f;
           5|foo(.*2)

       The result will be 20 because f is .*2, and during the first invocation of f . will be 5, and the second time it will be 10 (5 * 2), so the result will be  20.  Function  argu‐
       ments are filters, and filters expect an input when invoked.

       If you want the value-argument behaviour for defining simple functions, you can just use a variable:

           def addvalue(f): f as $f | map(. + $f);

       Or use the short-hand:

           def addvalue($f): ...;

       With  either definition, addvalue(.foo) will add the current input's .foo field to each element of the array. Do note that calling addvalue(.[]) will cause the map(. + $f) part
       to be evaluated once per value in the value of . at the call site.

       Multiple definitions using the same function name are allowed. Each re-definition replaces the previous one for the same number of function arguments, but only  for  references
       from functions (or main program) subsequent to the re-definition. See also the section below on scoping.

           jq 'def addvalue(f): . + [f]; map(addvalue(.[0]))'
              [[1,2],[10,20]]
           => [[1,2,1], [10,20,10]]

           jq 'def addvalue(f): f as $x | map(. + $x); addvalue(.[0])'
              [[1,2],[10,20]]
           => [[1,2,1,2], [10,20,1,2]]

### 作用域

   Scoping
       There  are two types of symbols in jq: value bindings (a.k.a., "variables"), and functions. Both are scoped lexically, with expressions being able to refer only to symbols that
       have been defined "to the left" of them. The only exception to this rule is that functions can refer to themselves so as to be able to create recursive functions.

       For example, in the following expression there is a binding which is visible "to the right" of it, ... | .*3 as $times_three | [. + $times_three] | ..., but not "to the  left".
       Consider this expression now, ... | (.*3 as $times_three | [.+ $times_three]) | ...: here the binding $times_three is not visible past the closing parenthesis.

### Reduce

   Reduce
       The  reduce  syntax in jq allows you to combine all of the results of an expression by accumulating them into a single answer. As an example, we'll pass [3,2,1] to this expres‐
       sion:

           reduce .[] as $item (0; . + $item)

       For each result that .[] produces, . + $item is run to accumulate a running total, starting from 0. In this example, .[] produces the results 3, 2, and 1, so the effect is sim‐
       ilar to running something like this:

           0 | (3 as $item | . + $item) |
               (2 as $item | . + $item) |
               (1 as $item | . + $item)

           jq 'reduce .[] as $item (0; . + $item)'
              [10,2,5,3]
           => 20

   isempty(exp)
       Returns true if exp produces no outputs, false otherwise.

           jq 'isempty(empty)'
              null
           => true

   limit(n; exp)
       The limit function extracts up to n outputs from exp.

           jq '[limit(3;.[])]'
              [0,1,2,3,4,5,6,7,8,9]
           => [0,1,2]

   first(expr), last(expr), nth(n; expr)
       The first(expr) and last(expr) functions extract the first and last values from expr, respectively.

       The nth(n; expr) function extracts the nth value output by expr. This can be defined as def nth(n; expr): last(limit(n + 1; expr));. Note that nth(n; expr) doesn't support neg‐
       ative values of n.

           jq '[first(range(.)), last(range(.)), nth(./2; range(.))]'
              10
           => [0,9,5]

   first, last, nth(n)
       The first and last functions extract the first and last values from any array at ..

       The nth(n) function extracts the nth value of any array at ..

           jq '[range(.)]|[first, last, nth(5)]'
              10
           => [0,9,5]

   foreach
       The foreach syntax is similar to reduce, but intended to allow the construction of limit and reducers that produce intermediate results (see example).

       The form is foreach EXP as $var (INIT; UPDATE; EXTRACT). Like reduce, INIT is evaluated once to produce a state value, then each output of EXP is bound to $var, UPDATE is eval‐
       uated  for  each output of EXP with the current state and with $var visible. Each value output by UPDATE replaces the previous state. Finally, EXTRACT is evaluated for each new
       state to extract an output of foreach.

       This is mostly useful only for constructing reduce- and limit-like functions. But it is much more general, as it allows for partial reductions (see the example below).

           jq '[foreach .[] as $item ([[],[]]; if $item == null then [[],.[0]] else [(.[0] + [$item]),[]] end; if $item == null then .[1] else empty end)]'
              [1,2,3,4,null,"a","b",null]
           => [[1,2,3,4],["a","b"]]

### 递归

   Recursion
       As described above, recurse uses recursion, and any jq function can be recursive. The while builtin is also implemented in terms of recursion.

       Tail calls are optimized whenever the expression to the left of the recursive call outputs its last value. In practice this means that the expression to the left of the  recur‐
       sive call should not produce more than one output for each input.

       For example:

           def recurse(f): def r: ., (f | select(. != null) | r); r;

           def while(cond; update):
             def _while:
               if cond then ., (update | _while) else empty end;
             _while;

           def repeat(exp):
             def _repeat:
               exp, _repeat;
             _repeat;

### 生成器和迭代器

   Generators and iterators
       Some  jq  operators  and functions are actually generators in that they can produce zero, one, or more values for each input, just as one might expect in other programming lan‐
       guages that have generators. For example, .[] generates all the values in its input (which must be an array or an object), range(0; 10) generates the integers between 0 and 10,
       and so on.

       Even the comma operator is a generator, generating first the values generated by the expression to the left of the comma, then for each of those, the values generate by the ex‐
       pression on the right of the comma.

       The empty builtin is the generator that produces zero outputs. The empty builtin backtracks to the preceding generator expression.

       All jq functions can be generators just by using builtin generators. It is also possible to define new generators using only recursion and the comma operator. If the  recursive
       call(s)  is(are) "in tail position" then the generator will be efficient. In the example below the recursive call by _range to itself is in tail position. The example shows off
       three advanced topics: tail recursion, generator construction, and sub-functions.

           jq 'def range(init; upto; by): def _range: if (by > 0 and . < upto) or (by < 0 and . > upto) then ., ((.+by)|_range) else . end; if by == 0 then init else init|_range end | select((by > 0 and . < upto) or (by < 0 and . > upto)); range(0; 10; 3)'
              null

           => 0, 3, 6, 9

           jq 'def while(cond; update): def _while: if cond then ., (update | _while) else empty end; _while; [while(.<100; .*2)]'
              1
           => [1,2,4,8,16,32,64]



## IO 操作

       At this time jq has minimal support for I/O, mostly in the form of control over when inputs are read. Two builtins functions are provided for this, input and inputs, that  read
       from the same sources (e.g., stdin, files named on the command-line) as jq itself. These two builtins, and jq's own reading actions, can be interleaved with each other.

       Two builtins provide minimal output capabilities, debug, and stderr. (Recall that a jq program's output values are always output as JSON texts on stdout.) The debug builtin can
       have application-specific behavior, such as for executables that use the libjq C API but aren't the jq executable itself. The stderr builtin outputs its input in  raw  mode  to
       stder with no additional decoration, not even a newline.

       Most jq builtins are referentially transparent, and yield constant and repeatable value streams when applied to constant inputs. This is not true of I/O builtins.

   input
       Outputs one new input.

   inputs
       Outputs all remaining inputs, one by one.

       This is primarily useful for reductions over a program's inputs.

   debug
       Causes  a debug message based on the input value to be produced. The jq executable wraps the input value with ["DEBUG:", <input-value>] and prints that and a newline on stderr,
       compactly. This may change in the future.

   stderr
       Prints its input in raw and compact mode to stderr with no additional decoration, not even a newline.

   input_filename
       Returns the name of the file whose input is currently being filtered. Note that this will not work well unless jq is running in a UTF-8 locale.

   input_line_number
       Returns the line number of the input currently being filtered.

## 流式

       With the --stream option jq can parse input texts in a streaming fashion, allowing jq programs to start processing large JSON texts immediately rather than after the parse com‐
       pletes. If you have a single JSON text that is 1GB in size, streaming it will allow you to process it much more quickly.

       However, streaming isn't easy to deal with as the jq program will have [<path>, <leaf-value>] (and a few other forms) as inputs.

       Several builtins are provided to make handling streams easier.

       The examples below use the streamed form of [0,[1]], which is [[0],0],[[1,0],1],[[1,0]],[[1]].

       Streaming  forms  include  [<path>, <leaf-value>] (to indicate any scalar value, empty array, or empty object), and [<path>] (to indicate the end of an array or object). Future
       versions of jq run with --stream and -seq may output additional forms such as ["error message"] when an input text fails to parse.

   truncate_stream(stream_expression)
       Consumes a number as input and truncates the corresponding number of path elements from the left of the outputs of the given streaming expression.

           jq '[1|truncate_stream([[0],1],[[1,0],2],[[1,0]],[[1]])]'
              1
           => [[[0],2],[[0]]]

   fromstream(stream_expression)
       Outputs values corresponding to the stream expression's outputs.

           jq 'fromstream(1|truncate_stream([[0],1],[[1,0],2],[[1,0]],[[1]]))'
              null
           => [2]

   tostream
       The tostream builtin outputs the streamed form of its input.

           jq '. as $dot|fromstream($dot|tostream)|.==$dot'
              [0,[1,{"a":1},{"b":2}]]
           => true

## 赋值

ASSIGNMENT
       Assignment works a little differently in jq than in most programming languages. jq doesn't distinguish between references to and copies of something - two objects or arrays are
       either equal or not equal, without any further notion of being "the same object" or "not the same object".

       If  an  object  has  two  fields which are arrays, .foo and .bar, and you append something to .foo, then .bar will not get bigger, even if you've previously set .bar = .foo. If
       you're used to programming in languages like Python, Java, Ruby, Javascript, etc. then you can think of it as though jq does a full deep copy of every object before it does the
       assignment (for performance it doesn't actually do that, but that's the general idea).

       This  means that it's impossible to build circular values in jq (such as an array whose first element is itself). This is quite intentional, and ensures that anything a jq pro‐
       gram can produce can be represented in JSON.

       All the assignment operators in jq have path expressions on the left-hand side (LHS). The right-hand side (RHS) provides values to set to the paths named by the  LHS  path  ex‐
       pressions.

       Values  in jq are always immutable. Internally, assignment works by using a reduction to compute new, replacement values for . that have had all the desired assignments applied
       to ., then outputting the modified value. This might be made clear by this example: {a:{b:{c:1}}} | (.a.b|=3), .. This will output {"a":{"b":3}} and {"a":{"b":{"c":1}}} because
       the last sub-expression, ., sees the original value, not the modified value.

       Most users will want to use modification assignment operators, such as |= or +=, rather than =.

       Note  that the LHS of assignment operators refers to a value in .. Thus $var.foo = 1 won't work as expected ($var.foo is not a valid or useful path expression in .); use $var |
       .foo = 1 instead.

       Note too that .a,.b=0 does not set .a and .b, but (.a,.b)=0 sets both.

   Update-assignment: |=
       This is the "update" operator '|='. It takes a filter on the right-hand side and works out the new value for the property of . being  assigned  to  by  running  the  old  value
       through  this  expression.  For  instance, (.foo, .bar) |= .+1 will build an object with the "foo" field set to the input's "foo" plus 1, and the "bar" field set to the input's
       "bar" plus 1.

       The left-hand side can be any general path expression; see path().

       Note that the left-hand side of '|=' refers to a value in .. Thus $var.foo |= . + 1 won't work as expected ($var.foo is not a valid or useful path expression in .); use $var  |
       .foo |= . + 1 instead.

       If the right-hand side outputs no values (i.e., empty), then the left-hand side path will be deleted, as with del(path).

       If  the  right-hand  side outputs multiple values, only the first one will be used (COMPATIBILITY NOTE: in jq 1.5 and earlier releases, it used to be that only the last one was
       used).

           jq '(..|select(type=="boolean")) |= if . then 1 else 0 end'
              [true,false,[5,true,[true,[false]],false]]
           => [1,0,[5,1,[1,[0]],0]]

   Arithmetic update-assignment: +=, -=, *=, /=, %=, //=
       jq has a few operators of the form a op= b, which are all equivalent to a |= . op b. So, += 1 can be used to increment values, being the same as |= . + 1.

           jq '.foo += 1'
              {"foo": 42}
           => {"foo": 43}

   Plain assignment: =
       This is the plain assignment operator. Unlike the others, the input to the right-hand-side (RHS) is the same as the input to the left-hand-side (LHS) rather than the  value  at
       the LHS path, and all values output by the RHS will be used (as shown below).

       If  the RHS of '=' produces multiple values, then for each such value jq will set the paths on the left-hand side to the value and then it will output the modified .. For exam‐
       ple, (.a,.b)=range(2) outputs {"a":0,"b":0}, then {"a":1,"b":1}. The "update" assignment forms (see above) do not do this.

       Provide input '{"a": {"b": 10}, "b": 20}' to the programs:

       .a = .b

       The former will set the "a" field of the input to the "b" field of the input, and produce the output {"a": 20, "b": 20}. The latter will set the "a" field of the input  to  the
       "a" field's "b" field, producing {"a": 10, "b": 20}.

       outputs '{"a":0,"b":0}', '{"a":1,"b":1}', and '{"a":2,"b":2}', while

       outputs just '{"a":0,"b":0}'.

   Complex assignments
       Lots  more  things are allowed on the left-hand side of a jq assignment than in most languages. We've already seen simple field accesses on the left hand side, and it's no sur‐
       prise that array accesses work just as well:

           .posts[0].title = "JQ Manual"

       What may come as a surprise is that the expression on the left may produce multiple results, referring to different points in the input document:

           .posts[].comments |= . + ["this is great"]

       That example appends the string "this is great" to the "comments" array of each post in the input (where the input is an object with a  field  "posts"  which  is  an  array  of
       posts).

       When  jq  encounters an assignment like 'a = b', it records the "path" taken to select a part of the input document while executing a. This path is then used to find which part
       of the input to change while executing the assignment. Any filter may be used on the left-hand side of an equals - whichever paths it selects from the input will be  where  the
       assignment is performed.

       This  is a very powerful operation. Suppose we wanted to add a comment to blog posts, using the same "blog" input above. This time, we only want to comment on the posts written
       by "stedolan". We can find those posts using the "select" function described earlier:

           .posts[] | select(.author == "stedolan")

       The paths provided by this operation point to each of the posts that "stedolan" wrote, and we can comment on each of them in the same way that we did before:

           (.posts[] | select(.author == "stedolan") | .comments) |=
               . + ["terrible."]

## 模块

MODULES
       jq has a library/module system. Modules are files whose names end in .jq.

       Modules imported by a program are searched for in a default search path (see below). The import and include directives allow the importer to alter this path.

       Paths in the a search path are subject to various substitutions.

       For paths starting with "~/", the user's home directory is substituted for "~".

       For paths starting with "$ORIGIN/", the path of the jq executable is substituted for "$ORIGIN".

       For paths starting with "./" or paths that are ".", the path of the including file is substituted for ".". For top-level programs given on the command-line, the current  direc‐
       tory is used.

       Import directives can optionally specify a search path to which the default is appended.

       The default search path is the search path given to the -L command-line option, else ["~/.jq", "$ORIGIN/../lib/jq", "$ORIGIN/../lib"].

       Null and empty string path elements terminate search path processing.

       A dependency with relative path "foo/bar" would be searched for in "foo/bar.jq" and "foo/bar/bar.jq" in the given search path. This is intended to allow modules to be placed in
       a directory along with, for example, version control files, README files, and so on, but also to allow for single-file modules.

       Consecutive components with the same name are not allowed to avoid ambiguities (e.g., "foo/foo").

       For example, with -L$HOME/.jq a module foo can be found in $HOME/.jq/foo.jq and $HOME/.jq/foo/foo.jq.

       If "$HOME/.jq" is a file, it is sourced into the main program.

   import RelativePathString as NAME [<metadata>];
       Imports a module found at the given path relative to a directory in a search path. A ".jq" suffix will be added to the relative path string. The module's symbols  are  prefixed
       with "NAME::".

       The  optional  metadata  must  be  a constant jq expression. It should be an object with keys like "homepage" and so on. At this time jq only uses the "search" key/value of the
       metadata. The metadata is also made available to users via the modulemeta builtin.

       The "search" key in the metadata, if present, should have a string or array value (array of strings); this is the search path to be prefixed to the top-level search path.

   include RelativePathString [<metadata>];
       Imports a module found at the given path relative to a directory in a search path as if it were included in place. A ".jq" suffix will be added to the relative path string. The
       module's symbols are imported into the caller's namespace as if the module's content had been included directly.

       The  optional  metadata  must  be  a constant jq expression. It should be an object with keys like "homepage" and so on. At this time jq only uses the "search" key/value of the
       metadata. The metadata is also made available to users via the modulemeta builtin.

   import RelativePathString as $NAME [<metadata>];
       Imports a JSON file found at the given path relative to a directory in a search path. A ".json" suffix will be added to the relative path string. The file's data will be avail‐
       able as $NAME::NAME.

       The  optional  metadata  must  be  a constant jq expression. It should be an object with keys like "homepage" and so on. At this time jq only uses the "search" key/value of the
       metadata. The metadata is also made available to users via the modulemeta builtin.

       The "search" key in the metadata, if present, should have a string or array value (array of strings); this is the search path to be prefixed to the top-level search path.

   module <metadata>;
       This directive is entirely optional. It's not required for proper operation. It serves only the purpose of providing metadata that can be read with the modulemeta builtin.

       The metadata must be a constant jq expression. It should be an object with keys like "homepage". At this time jq doesn't use this metadata, but it is made  available  to  users
       via the modulemeta builtin.

   modulemeta
       Takes a module name as input and outputs the module's metadata as an object, with the module's imports (including metadata) as an array value for the "deps" key.

       Programs can use this to query a module's metadata, which they could then use to, for example, search for, download, and install missing dependencies.

## 颜色控制

COLORS
       To configure alternative colors just set the JQ_COLORS environment variable to colon-delimited list of partial terminal escape sequences like "1;31", in this order:

       ○   color for null

       ○   color for false

       ○   color for true

       ○   color for numbers

       ○   color for strings

       ○   color for arrays

       ○   color for objects

       The default color scheme is the same as setting "JQ_COLORS=1;30:0;39:0;39:0;39:0;32:1;39:1;39".

       This  is not a manual for VT100/ANSI escapes. However, each of these color specifications should consist of two numbers separated by a semi-colon, where the first number is one
       of these:

       ○   1 (bright)

       ○   2 (dim)

       ○   4 (underscore)

       ○   5 (blink)

       ○   7 (reverse)

       ○   8 (hidden)

       and the second is one of these:

       ○   30 (black)

       ○   31 (red)

       ○   32 (green)

       ○   33 (yellow)

       ○   34 (blue)

       ○   35 (magenta)

       ○   36 (cyan)

       ○   37 (white)
