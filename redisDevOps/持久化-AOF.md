# AOF

append only file，以独立日志的方式记录每次写命令。恢复时重新执行文件中的所有命令达到恢复的目的。

优点：实时性。

## 开启

```
appendonly yes
```

## 工作流程

- 命令写入（append）：写入缓冲区 aof_buf
- 文件同步（sync）：从缓冲区同步到硬盘
- 文件重写（rewrite）：定期重写，压缩
- 重启加载（load）

### 命令写入

直接适用文本协议（即字符串形式）

为什么使用文本协议：
- 很好的兼容性
- 避免了二次处理的开销
- 易读，可直接修改和处理

格式：

```c
*3\r\n$3\r\nset\r\n$5\r\nhello\r\n$5\r\nworld\r\n
```
> ```
> *3
> $3
> set
> $5
> hello
> $5
> world

### 文件同步

由 `appendfsync` 配置控制，三种方式：

- always，一次写入执行一次
- everysec，每秒同步一次
- no，靠系统自己同步


运维建议：

- always 影响性能，开启后一般的 SATA 只支持几百 TPS
- no 无法保证安全性
- everysec 建议配置项，最多丢失 1s 的数据（严格来说是 2s）

### 重写机制

随着 AOF 开启，文件会越来越多，因此有重写机制。重写机制就是把所有数据转化为写命令同步到 AOF 文件中。（短平快的做法）

变小的变化来自哪里？

- 不写已经超时的数据
- 只写最终数据，没有中间状态数据（如先增后删的不会记录）
- 包含命令合并（如多次执行 lpush 合并成一条）

> 对于非字符串的数据过长的 AOF 记录，会按 64 个元素为界限拆分为多条

重写的触发时机

- 手动：bgrewriteaof
- 自动，按以下条件 与 （&&）
    - AOF 文件大于 auto-aof-rewrite-min-size 时
    - 当前大小和上次重写后的比例大于 auto-aof-rewrite-percentage 时

重写过程

- 启动 AOF 重写
- 父进程执行 fork 操作创建子进程执行
- 根据内存快照执行 AOF 写入，期间父进程继续提供服务，将新来的写命令记录到 **AOF重写缓冲区**
- 重写完成，通知主进程，子进程退出
- 父进程把 AOF重写缓冲区 写入到 AOF文件
- 新 AOF 文件替换旧文件
- 结束

### 重启载入

启动时当开启 AOF 后优先使用 AOF 载入数据。否则按 RDB 方式启动。若在载入 AOF 文件或 RDB 文件中发生错误将启动失败。否则会成功。

AOF 文件有可能结尾不完整，可以通过 `aof-load-truncated` 来兼容这种情况，默认是开启的。