# 缓存设计

## 收益与成本

收益：
- 加速读写
- 后端负载降压

成本：

- 数据不一致
- 代码维护成本
- 运维成本

场景：
- 开销大的复杂计算做缓存
- 加速请求响应

## 缓存更新策略

缓存都是有生命周期的，什么时候删除或更新在不同策略我会会有不同的影响。

一般三类：

- LRU/LFU/FIFO 算法
- 超时删除
- 主动更新

建议：
- 低一致性业务：配置最大内存 + 淘汰策略
- 高一致性业务：超时剔除 + 主动更新

面试中常问这里，所以从网上扩展一下。

- 先更新缓存，后更新数据库
    - 如果数据库更新失败，则造成不一致
- 先删除缓存，后更新数据库
    - 可能在删除缓存和更新数据库之间，由另一个线程读并更新了缓存，更新的仍是旧数据（不建议）
- 先更新数据库，后更新缓存
    - 在缓存还没有的时候，依然会有不一致的问题
    - 上述具体如：读线程先读出来后，另一个线程进行了写数据库和更新缓存，然后读线程再次更新缓存，造成不一致。（概率很低）
- 先更新数据库，后删除缓存（和上一条会有一样的问题）
- 延迟双删（先删除缓存，再更新数据库，再延时删除缓存）
    - 考略因素：延时的时长 问题，中间有两次无缓存的访问
- 串行化：内存队列、第三方队列

（用 redis 锁做版本控制对缓存进行更新怎么样？）

## 穿透

缓存穿透：查询了不存在的数据，导致直达数据库。

解决方案：
- 缓存空对象
- 布隆过滤器

## 无底洞优化

无底洞概念：导致节点投入越多耗时不断增加。

要知道什么原因导致无底洞，本来添加了缓存后一次访问肯定没问题，而产生的原因在于……

无底洞原因：客户端一次批量操作涉及多次网络操作。

解决（主要在 IO  优化上）：
- 命令本身优化：n 次 get -> pipeline -> 按分片分组 + mget
- hash_tag 将相关 key 分配到一个节点。（缺点：容易出现数据倾斜）

## 雪崩

雪崩原因：同一时间大量 key 过期（或宕机无法提供服务），导致大量请求访问存储层。


解决：
- 缓存高可用（针对宕机）
- 使用隔离组件为后端限流降级（针对宕机）
- 同一时间大量过期同样属于 热 key 问题，见下文
    - 永不过期（不过期 或 到期前重建）
    - 离散过期时间
    - 单线程重建所有缓存
    - 双缓存，二级缓存有更长的过期时间

## 热点 key

危害：
- 请求压力：可能会超出 redis 承受的 ops。
- 缓存重建：（见下一节）

寻找热 key：
- 客户端：全局字典统计计数（代码侵入、难运维、存在内存泄漏风险）
- 代理端：如 Twemproxy、Codis 所有客户端请求都是通过代理端完成的
- 服务端：`monitor` 命令获取近 n 条命令，并实现统计（此命令会存在内存暴增风险）
- 机器：通过抓包分析（Redis 是通过基于 TCP 的 RESP 协议通信的）

热点 key 解决：
- 拆分复杂结构：如 hash 再拆
- 迁移到单独的节点
- 服务端本地再加缓存 + 发布订阅机制更新本地缓存

## 热点 key 的重建

问题原因：热 key 一旦过期，重建过程无法在同一时间完成，造成大量请求到达存储层或大量线程重建缓存（雪崩）。

解决：
- 永不过期（不设置过期时间或在将要超时前用一个线程构建缓存）
- 离散过期时间
- 互斥锁保证只一个线程更新缓存（sigleflight）
- 使用双缓存，备用缓存设置的过期时间更长

## 缓存击穿

singleflight

## 处理大key

大 key 定义：占用空间大的值

- 字符串超过 10KB
- 非字符串元素个数超过 5000

危害:
- 内存空间分布不均
- 造成网络拥塞
- 造成 redis 超时阻塞

如何发现：
- 主动发现，`redis --bigkeys`
- 主动发现（根据自己定义的大小）， `scan` + `debug object <key>` 查看 `serializedlength` 属性
- 被动发现，有慢查询、网卡跑满时检查

如何删除：
- string 类型可以直接删除（即便 10M 的也只用 1ms）
- 其他类型渐进式删除（SCAN/HSCAN/SSCAN/ZSCAN + 对应删除操作）

注：Redis 4.0 后支持 lazy delete free 模式，删除 bigkey 不再会阻塞