# 缓存设计

## 收益与成本

收益：
- 加速读写
- 后端负载降压

成本：

- 数据不一致
- 代码维护成本
- 运维成本

场景：
- 开销大的复杂计算
- 加速请求响应

## 缓存更新策略

建议：
- 低一致性业务：配置最大内存 + 淘汰策略
- 高一致性业务：超时剔除 + 主动更新

## 穿透

缓存穿透：查询了不存在的数据，导致直达数据库。

解决方案：
- 缓存空对象
- 布隆过滤器

## 无底洞优化

无底洞原因：客户端一次批量操作涉及多次网络操作，导致节点投入越多耗时不断增加。

解决（主要在 IO  优化上）：
- 命令本身优化：n 次 get -> pipeline -> mget 
- hash_tag 将相关 key 分配到一个节点。（缺点：容易出现数据倾斜）

## 雪崩

雪崩原因：同一时间大量 key 过期（或宕机无法提供服务），导致大量请求访问存储层。


解决：
- 缓存高可用（针对宕机）
- 使用隔离组件为后端限流降级（针对宕机）
- 同一时间大量过期同样属于 热 key 问题，见下文

## 热点 key

危害：
- 请求压力：可能会超出 redis 承受的 ops。
- 缓存重建：（见下一节）

寻找热 key：
- 客户端：全局字典统计计数（代码侵入、难运维、存在内存泄漏风险）
- 代理端：如 Twemproxy、Codis 所有客户端请求都是通过代理端完成的
- 服务端：`monitor` 命令获取近 n 条命令，并实现统计（此命令会存在内存暴增风险）
- 机器：通过抓包分析（Redis 是通过基于 TCP 的 RESP 协议通信的）

热点 key 解决：
- 拆分复杂结构：如 hash 再拆
- 迁移到单独的节点
- 服务端本地再加缓存 + 发布订阅机制更新本地缓存

## 热点 key 的重建

问题原因：热 key 一旦过期，重建过程无法在同一时间完成，造成大量请求到达存储层或大量线程重建缓存。

解决：
- 永不过期（不设置过期时间或在将要超时前用一个线程构建缓存）
- 互斥锁保证只一个线程更新缓存（sigleflight）
- 使用双缓存，备用缓存设置的过期时间更长

## 缓存击穿

singleflight

## 处理大key

大 key 定义：占用空间大的值
- 字符串超过 10KB
- 非字符串元素个数超过 5000

危害:
- 内存空间分布不均
- 造成网络拥塞
- 造成 redis 超时阻塞

如何发现：
- 主动发现，`redis --bigkeys`
- 主动发现（根据自己定义的大小）， `scan` + `debug object <key>` 查看 `serializedlength` 属性
- 被动发现，有慢查询、网卡跑满时检查

如何删除：
- string 类型可以直接删除（即便 10M 的也只用 1ms）
- 其他类型渐进式删除（补充命令）

注：Redis 4.0 后支持 lazy delete free 模式，删除 bigkey 不再会阻塞