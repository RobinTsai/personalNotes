# 运维技巧

- `redis-cli monitor | tee > /tmp/redis_monitor.log` 命令可以查看当前 redis 在执行什么命令。慎用，内存风暴风险。
- `redis-cli slowlog len` 查看 slowlog 条数
- `redis-cli slowlog get 129 > slow-129.log` 将 slowlog 导出最近的 129 条


## 安装

- 从 https://download.redis.io/releases/ 中下载对应版本
- tar -zxvf xxx.tar.gz 解压
- 进入解压后 src 目录，执行 `make install PREFIX=/usr/local/redis` 指定安装目录

## 问题记录

### scan 并发量大导致 CPU 占用 100%

命令：`scan INDEX match XXX:* count N`

关键现象：
- 流量偏移到 redis master 节点
- CPU 很高期间慢查询日志有 scan 操作，起止时间与 CPU 飙高时间差不多

原因：业务中有多个 SCAN 命令并发跑，导致流量偏移到 master 并 CPU 飙升。

[参考](https://zhuanlan.zhihu.com/p/381813397)

### sentinel 信息异常令人疑惑

在线上某个 sentinel 中执行 `info sentinel` 出现

```sh
10.11.54.187:26372> info sentinel
# Sentinel
sentinel_masters:1
...
master0:name=mymaster,status=sdown,address=10.11.54.187:6704,slaves=2,sentinels=4
```

其实只有三个 sentinel 监听这个集群，但为什么 sentinels=4 呢？

这是因为 sentinel 配置文件中记录有三个 `sentinel known-sentinel` 记录，所以加上自己是 4 个。我们知道 sentinel 每查找 peer 后，会向自己的配置文件中追加 peer 的信息，所以这里可以推导出在历史中此配置文件添加了其他三个 sentinel。

### bgsave 失败导致所有写数据失败

首先要知道配置 `stop-writes-on-bgsave-error`，配置当 bgsave 失败后是否阻塞写操作，为 `yes` 则在 bgsave 失败时导致写失败。

进一步地，底层还有一个问题会产生令人疑惑的现象：在空闲内存空间足够的情况下 bgsave 仍然失败。

我们在线上有遇到了这样的问题，当时我们发现，redis 占用内存占总机器内存的 60% 左右即发生此问题（未设置实例上限），而根据日志记录，每次 bgsave 只用到几十兆的内存。

从 [redis-faq](https://redis.io/docs/getting-started/faq/) 的 *Background saving fails with a fork() error on Linux?* 一节中可以了解到：

**理论上 bgsave 子进程需要 copy 整个 redis 内存以完成 dump DB，但得益于 Copy-on-Write 机制实际 copy 的内存只有那些需要改动的页。但 Linux 无法提前知道子进程最终到底会占用多少内存，所以在系统配置 overcommit_memory 为 0 时，除非空闲内存真的足够 copy 所有的 redis 的使用内存，否则 fork 将失败。**

解决办法：linux 执行 `echo 1 > /proc/sys/vm/overcommit_memory`。


内核参数 vm.overcommit_memory 详解，参考 [kernel doc](https://www.kernel.org/doc/Documentation/vm/overcommit-accounting)：

> 以下中文解释来自于其他网页的参考。
> 亦可通过 `sysctl vm.overcommit_memory` 查看配置。

可选值 0、1、2。

- 0，表示内核将检查是否有足够内存以供应用进程使用，若不够申请失败
- 1，表示内核允许分配所有物理内存而不管当前内存状态如何
- 2，表示内核允许分配超过所有物理内存和交换内存空间总和的内存

扩展：OOM [参考](https://www.linuxembedded.fr/2020/01/overcommit-memory-in-linux)

当开启 overcommit 后，在内存被用完继续申请时会导致 OOM Killer 杀死其他进程，它有一套选择机制。此时，可用 `vm.overcommit_ratio (percentage)` 或 `'vm.overcommit_kbytes' (absolute value)` 调整用户空间 apps 对内存的使用量。

> What is 'overcommit'?
> In linux, overcommit means the kernel allows more memory to be defined as allocated, which means the allocation adds to the VSZ or virtual set size, than the virtual memory size of the linux system can provide.
