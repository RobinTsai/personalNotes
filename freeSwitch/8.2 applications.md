# bridge_export

- 作用：跨任何 bridge 导出一个 *通道变量*，此 app 和 `export` 的差别在于它可以工作在任何 `bridge` 类型中，而不仅仅从 `dialplan` 调用的 `bridge`。例如：`bridge_export` 能在 `uuid_transfer` 时导出变量，而 `export` 不能
- 参考：[mod_dptools: bridge export](http://git.flyudesk.com/ccps/udesk_tts_proxy/merge_requests/2)
- 用法如下

```xml
<condition field="destination_number" expression="^ads-(.*)" break="never">
    <action application="bridge_export" data="lin_workflow=out_auto"/>
</condition>
```

之后，在 bridge 执行之后，你可以在 aLeg 和 bLeg 都能看到如下信息：`[variable_bridge_export_vars] = [foo]`, `[variable_foo] = [bar]`


如果要约束导出只到 bLeg，使用 `nolocal:`

```xml
    <action application="bridge_export" data="nolocal:foo=bar"/>
```

# curl

作用：发一个 HTTP 请求并接收 response，输出为 text 文本或 json 对象，headers 是可选的输出。
参考：[mod_curl](https://developer.signalwire.com/freeswitch/FreeSWITCH-Explained/Modules/mod_curl_3965033)

四个地方：

- 配置。加载模块
- 应用。`<action application="curl" data="url [headers|json] [get|head|post [url_encode_data]]"/>`
- API。`curl url [headers|json|content-type <mime-type>|connect-timeout <seconds>|timeout <seconds>] [get|head|post|delete|put [data]]`
- LUA。

在应用中使用：

```xml
<!-- 普通使用，可以通过变量获取结果 curl_response_code curl_response_data -->
<action application="curl" data="url [headers|json] [get|head|post [url_encode_data]]"/>
<!-- 发送文件 -->
<action application="curl_sendfile" data="<url> <filename_post_name=/path/to/filename [nopost|foo1=bar1&foo2=bar2&...fooN=barN [event|none [uuid|identifier]]]"/>
<!-- 或使用变量形式发送文件 -->
<action application="set" data="curl_sendfile_report=event"/>
<action application="set" data="curl_sendfile_url=http://www.mydomain.com/test_files.php"/>
<action application="set" data="curl_sendfile_filename_element=myFile"/>
<action application="set" data="curl_sendfile_filename=/tmp/somefile.dmp"/>
<action application="set" data="curl_sendfile_extrapost=foo1=bar1&foo2=bar2&testing=a%20pain%20in%20the%20rear"/>
<action application="set" data="curl_sendfile_identifier=1234567890"/>
<action application="curl_sendfile"/>
```

# limit

作用：设置 to/from 呼叫的号码的数量。
原理：当 limit 达到时，呼叫自动 transfer 到指定上下文（默认到 `limit_exceeded` 的上下文）
命令：`limit <backend> <realm> <resource> <max[/interval]> [<transfer_destination_number> [<dialplan> [<context>]]`
示例：项目中在 lua 内使用了如下形式 `("limit hash %s %s %s !USER_BUSY", domain, dst_number, max)`
参考：[mod_dptools: limit](https://developer.signalwire.com/freeswitch/FreeSWITCH-Explained/Modules/mod-dptools/3375201/#limit)
注意：limit 只在给定的上下文中生效，如果你从 public 拨号计划中 transfer 到 default 拨号计划，刚刚设置的 limit 将会被重置
注意：NB（特别注意），如果限制在目的号码，然后呼叫被 transfer 到另一个 extension（即便在同一个上下文中），limit 也会被降低
注意：如果呼叫用 `REFER` 方法 transfer，limit 将不会减一（比如用手机段的 TRANSFER 按键）
注意：`limit_ignore_transfer` 为 true 在 transwer 时不会重置 call count；为 false 会在 transfer 时降低计数

> `max/interval` 表示可以控制每秒进多少呼叫
> `interval` 参数只用于 `hiredis` 的 backend，`hiredis` 是 redis 的客户端 SDK
>
> `!BUSY` 是告诉 `limit_hash` 当超限后自动挂断呼叫（格式：在 hangup cause 前加一个 `!`）
>
> backend 有哪些，该如何选择？
> 三种：
> - `hash`：使用了 mod_hash，速度最快，但不能持久化，支持 interval
> - `db`：使用了 mod_db，速度最慢，可以持久化，不支持 interval
> - `hiredis`：使用了 mod_hiredis，速度还OK，支持持久化，并且可配置持久化，支持集群，支持 interval

# respond

作用：发送指定 SIP response
使用：`<action application="respond" data="response_info"/>`
示例：`<anti-action application="respond" data="480 Try again later"/>`
注意：旧版本中可以使用 respond 响应 `180 Ringing`，但新版本要用 `ring_ready` application
