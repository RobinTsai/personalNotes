# go write tcp conn succeed but acturally failed


```go
// 使用 `nc -l -p 8080` 监听 8080 端口，并运行此程序
// 此程序每 2s 向 tcp 中写入时间，发送失败时会在此程序窗口显示此时间
// 在某时刻杀死 nc 程序，会发现：
//     nc 收到并显示的信息和此程序发送失败展示的信息不是连续的，而是丢失了一条。
// 例如 19:00:00 写入 nc 端，这时候立刻杀死 nc，则此程序窗口第一条信息是 19:00:04
// 也就是此程序认为 19:00:02 成功写入到了 tcp 中了，但实际对端未成功接收到。
//
// 学艺不精，这个问题本来应该知道，还是学过的知识不扎实。直接回顾原理吧：
//     写入 TCP 连接成功，只能表明成功写到本端的发送缓冲区成功，而不能表明对端能成功接收。
//     如果 TCP 断开连接，底层协议仍然会尝试重连（这时连接可能未关闭，而是不稳定状态），直到本端达到最大重传超时（一般 12 次），认为连接关闭。
//     当连接关闭后，必须要重新建立一个连接才能通信。
//     TCP 对端程序突然挂掉的话，是无法发送任何数据包的，包括 RST，所以本端无法立刻知道连接状态。
//     这种情况下只能重建网络来恢复通信。
// 所以我这里发现写入成功没有错误返回，但实际对端未收到。当程序需要写入一次就获取一次响应的话，要十分注意线程阻塞的问题，最好在获取响应的时候加上超时时间。
func main() {
	c, err := net.Dial("tcp", "0.0.0.0:8080")
	if err != nil {
		fmt.Println("dial err", err.Error())
		return
	}

	for {
		now := time.Now().String()
		_, err = fmt.Fprintf(c, "%s\n", now)
		if err != nil {
			fmt.Println("ERR", now, err.Error())
		}
		time.Sleep(time.Second * 2)
	}
}
```
